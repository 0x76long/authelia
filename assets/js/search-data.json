{
  
  "0": {
    "title": "Access Control",
    "content": "Access Control . Authelia allows to define a fine-grained rule-based access control policy in configuration. This list of rules is tested against any requests protected by Authelia and defines the level of authentication the user must pass to get access to the resource. . For instance a rule can look like this: . - domain: dev.example.com resources: - &quot;^/groups/dev/.*$&quot; subject: &quot;group:dev&quot; policy: two_factor . This rule matches when the request targets the domain dev.example.com and the path matches the regular expression ^/groups/dev/.*$. In that case, a two-factor policy is applied requiring the user to authenticate with two factors. . Configuration . Please check the dedicated documentation .",
    "url": "https://docs.authelia.com/features/access-control.html",
    "relUrl": "/features/access-control.html"
  }
  ,"1": {
    "title": "Access Control",
    "content": "Access Control . Access Control List . With Authelia you can define a list of rules that are going to be evaluated in sequential order when authorization is delegated to Authelia. . The first matching rule of the list defines the policy applied to the resource, if no rule matches the resource a customizable default policy is applied. . Access Control Rule . A rule defines two things: . the matching criteria of the request presented to the reverse proxy | the policy applied when all criteria match. | . The criteria are: . domain: domain targeted by the request. | resources: list of patterns that the path should match (one is sufficient). | subject: the user or group of users to define the policy for. | networks: the network range from where should comes the request. | . A rule is matched when all criteria of the rule match. . Policies . A policy represents the level of authentication the user needs to pass before being authorized to request the resource. . There exist 4 policies: . bypass: the resource is public as the user does not need any authentication to get access to it. | one_factor: the user needs to pass at least the first factor to get access to the resource. | two_factor: the user needs to pass two factors to get access to the resource. | deny: the user does not have access to the resource. | . Domains . The domains defined in rules must obviously be either a subdomain of the domain protected by Authelia or the protected domain itself. In order to match multiple subdomains, the wildcard matcher character *. can be used as prefix of the domain. For instance, to define a rule for all subdomains of example.com, one would use *.example.com in the rule. A single rule can define multiple domains for matching. . Resources . A rule can define multiple regular expressions for matching the path of the resource. If any one of them matches, the resource criteria of the rule matches. . Subjects . A subject is a representation of a user or a group of user for who the rule should apply. . For a user with unique identifier john, the subject should be user:john and for a group uniquely identified by developers, the subject should be group:developers. Similar to resources and domains you can define multiple subjects in a single rule. . Networks . A list of network ranges can be specified in a rule in order to apply different policies when requests come from different networks. . The main use case is when, lets say a resource should be exposed both on the Internet and from an authenticated VPN for instance. Passing a second factor a first time to get access to the VPN and a second time to get access to the application can sometimes be cumbersome if the endpoint is not considered overly sensitive. . Even if Authelia provides this flexibility, you might prefer a higher level of security and avoid this option entirely. You and only you can define your security policy and it’s up to you to configure Authelia accordingly. . Complete example . Here is a complete example of complex access control list that can be defined in Authelia. . access_control: default_policy: deny rules: - domain: public.example.com policy: bypass - domain: secure.example.com policy: one_factor networks: - 192.168.1.0/24 - domain: - secure.example.com - private.example.com policy: two_factor - domain: singlefactor.example.com policy: one_factor - domain: &quot;mx2.mail.example.com&quot; subject: &quot;group:admins&quot; policy: deny - domain: &quot;*.example.com&quot; subject: - &quot;group:admins&quot; - &quot;group:moderators&quot; policy: two_factor - domain: dev.example.com resources: - &quot;^/groups/dev/.*$&quot; subject: &quot;group:dev&quot; policy: two_factor - domain: dev.example.com resources: - &quot;^/users/john/.*$&quot; subject: &quot;user:john&quot; policy: two_factor .",
    "url": "https://docs.authelia.com/configuration/access-control.html",
    "relUrl": "/configuration/access-control.html"
  }
  ,"2": {
    "title": "Architecture",
    "content": "Architecture . Authelia is a companion of reverse proxies like Nginx, Traefik and HAProxy. It can be seen as an extension of those proxies providing authentication functions and a login portal. . As shown in the following architecture diagram, Authelia is directly connected to the reverse proxy but never directly connected to application backends. . . Workflow . Reverse proxies are configured so that every incoming request generates an authentication request sent to Authelia. Authelia responds and will instruct the reverse proxy to either allow the incoming request to pass through, or block it because the user is not authenticated or is not sufficiently authorized. . Step by step . When the first request of an unauthenticated user hits the reverse proxy, Authelia determines the user is not authenticated because no session cookie has been sent along with the request. Consequently, Authelia redirects the user to the authentication portal provided by Authelia itself. The user can then execute the authentication workflow using that portal to obtain a session cookie valid for all subdomains of the domain protected by Authelia. . When the user visits the initial website again, the query is sent along with the session cookie which is forwarded in the authentication request to Authelia. This time, Authelia can verify the user is authenticated and order the reverse proxy to let the query pass through. . Sequence Diagram . Here is a description of the complete workflow: . . HTTP/HTTPS . Authelia only works for websites served over HTTPS because the session cookie can only be transmitted over secure connections. Please note that it has been decided that we won’t support websites served over HTTP in order to avoid any risk due to misconfiguration. (see #590). . If a self-signed certificate is required, the following command can be used to generate one: . # Generate a certificate covering &quot;example.com&quot; for one year in the /tmp/certs/ directory. $ docker run authelia/authelia authelia certificates generate --host example.com --dir /tmp/certs/ .",
    "url": "https://docs.authelia.com/home/architecture.html",
    "relUrl": "/home/architecture.html"
  }
  ,"3": {
    "title": "Authelia Scripts",
    "content": "Authelia Scripts . Authelia comes with a set of dedicated scripts doing a broad range of operations such as building the distributed version of Authelia, building the Docker image, running suites, testing the code, etc… . Those scripts becomes available after sourcing the bootstrap.sh script with . $ source bootstrap.sh . Then, you can access the scripts usage by running the following command: . $ authelia-scripts --help . For instance, you can build Authelia (Go binary and frontend) with: . $ authelia-scripts build . Or build the official Docker image with: . $ authelia-scripts docker build . Or start the Standalone suite with: . $ authelia-scripts suites setup Standalone . You will find more information in the scripts usage helpers. .",
    "url": "https://docs.authelia.com/contributing/authelia-scripts.html",
    "relUrl": "/contributing/authelia-scripts.html"
  }
  ,"4": {
    "title": "Build & Dev",
    "content": "Build &amp; Dev . Authelia is written in Go and comes with a dedicated CLI called authelia-scripts which is available after running source bootstrap.sh. This CLI provides many useful tools to help you during development. . In order to build and contribute to Authelia, you need to make sure Go v1.13, Docker, docker-compose and Node v12 are installed on your machine. . Get started . Authelia is made of Go application serving the API and a React application for the portal. . In order to ease development, Authelia uses the concept of suites to run Authelia from source code so that your patches are included. This is a kind of virtual environment running Authelia in a complete ecosystem (LDAP, Redis, SQL server). Note that Authelia is hot-reloaded in the environment so that your patches are instantly included. . The next command starts the suite called Standalone: . $ authelia-scripts suites setup Standalone . Most of the suites are using docker-compose to bootstrap the environment. Therefore, you can check the logs of all application by running the following command on the component you want to monitor. . $ docker logs authelia_authelia-backend_1 -f . Then, edit the code and observe how Authelia is automatically reloaded. . Unit tests . To run the unit tests, run: . $ authelia-scripts unittest . Integration tests . Integration tests are located under the internal/suites directory and are based on Selenium. A suite is a combination of environment and tests. Executing a suite therefore means starting the environment, running the tests and tearing down the environment. Each step can be run independently: . # List the available suites $ authelia-scripts suites list Standalone DuoPush LDAP Traefik # Start the environment of Standalone suite. $ authelia-scripts suites setup Standalone # Run the tests related to the currently running suite. $ authelia-scripts suites test # Tear down the environment $ authelia-scripts suites teardown Standalone . In order to test all suites (approx 30 minutes), you need to make sure there is no currently running suite and then you should run: . $ authelia-scripts suites test . Also, you don’t need to start the suite before testing it. Given you’re not running any suite, just use the following command to test the Standalone suite. . $ authelia-scripts suites test Standalone . The suite will be spawned, tests will be run and then the suite will be teared down automatically. .",
    "url": "https://docs.authelia.com/contributing/build-and-dev.html",
    "relUrl": "/contributing/build-and-dev.html"
  }
  ,"5": {
    "title": "Deployment - Highly-Available",
    "content": "Highly-Available Deployment . Authelia can be deployed on bare metal or on Kubernetes with two different kind of artifacts: the distributable version (binary and public_html) or a Docker image. . NOTE: If not done already, we highly recommend you first follow the Getting Started documentation. . On Bare Metal . Authelia has been designed to be a proxy companion handling the authentication and authorization requests for your entire infrastructure. . As Authelia will be key to your architecture, it requires several components to make it highly-available. Deploying it in production means having an LDAP server for storing the information about the users, a Redis cache to store the user sessions in a distributed manner, a SQL server like MariaDB to persist user configurations and one or more nginx reverse proxies configured to be used with Authelia. With such a setup Authelia can easily be scaled to multiple instances to evenly handle the traffic. . Here are the available steps to deploy Authelia given the configuration file is /path/to/your/configuration.yml. Note that you can create your own configuration file from config.template.yml located at the root of the repo. . NOTE: Prefer using environment variables to set secrets in production otherwise pay attention to the permissions of the configuration file. See secrets for more information. . Deploy with the distributable version . # Build it if not done already $ authelia-scripts build $ authelia --config /path/to/your/configuration.yml . Deploy With Docker . $ docker run -v /path/to/your/configuration.yml:/etc/authelia/configuration.yml -e TZ=Europe/Paris authelia/authelia . FAQ . Why is this not automated? . Ansible would be a very good candidate to automate the installation of such an infrastructure on bare metal. We would be more than happy to review any PR on that matter. .",
    "url": "https://docs.authelia.com/deployment/deployment-ha.html",
    "relUrl": "/deployment/deployment-ha.html"
  }
  ,"6": {
    "title": "Deployment - Kubernetes",
    "content": "Deployment on Kubernetes . . UNDER CONSTRUCTION .",
    "url": "https://docs.authelia.com/deployment/deployment-kubernetes.html",
    "relUrl": "/deployment/deployment-kubernetes.html"
  }
  ,"7": {
    "title": "Deployment - Lite",
    "content": "Lite Deployment . Authelia can be deployed as a lite setup with minimal external dependencies. The setup is called lite because it reduces the number of components in the architecture to a reverse proxy such as Nginx, Traefik or HAProxy, Authelia and Redis. . This setup assumes you have basic knowledge and understanding of IP addresses, DNS and port forwarding. You should setup the domain you intend to protect with Authelia to point to your external IP address and port forward ports 80 and 443 to the host you plan to host the docker-compose.yml bundle. . Port 80 is utilised by LetsEncrypt for certificate challenges, this will automatically provision up-to-date certificates for your domain(s). . Traefik publishes the respective services with LetsEncrypt provided certificates on port 443. The provided examples protect the Traefik dashboard with Authelia’s one-factor auth (traefik.example.com) and two instances of the whoami container with Authelia being bypassed (public.example.com) and another with it’s two-factor auth (secure.example.com). . If you happen to already have an external SQL instance (MariaDB, MySQL or Postgres) this setup can easily be adapted to utilise said service. . Steps . git clone https://github.com/authelia/authelia.git | cd authelia/compose/lite | Modify the users_database.yml the default username and password is authelia | Modify the configuration.yml and docker-compose.yml with your respective domains and secrets | docker-compose up -d | . Reverse Proxy . The Lite bundle provides pre-made examples with Traefik2.x, you can swap this out for any of the supported proxies. . FAQ . Can you give more details on why this is not suitable for production environments? . This documentation gives instructions that will make Authelia non resilient to failures and non scalable by preventing you from running multiple instances of the application. This means that Authelia won’t be able to distribute the load across multiple servers and it will prevent failover in case of a crash or an hardware issue. .",
    "url": "https://docs.authelia.com/deployment/deployment-lite.html",
    "relUrl": "/deployment/deployment-lite.html"
  }
  ,"8": {
    "title": "Duo Push Notifications",
    "content": "Duo Push Notifications . Authelia supports mobile push notifications relying on Duo. . Follow the instructions in the dedicated documentation to know how to set up push notifications in Authelia. . Configuration . The configuration is as follows: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . The secret key is shown as an example, you also have the option to set it using an environment variable as described here. .",
    "url": "https://docs.authelia.com/configuration/duo-push-notifications.html",
    "relUrl": "/configuration/duo-push-notifications.html"
  }
  ,"9": {
    "title": "FAQ",
    "content": "Frequently asked questions . How can the backend be aware of the authenticated users? . This question is solved here. .",
    "url": "https://docs.authelia.com/faq.html",
    "relUrl": "/faq.html"
  }
  ,"10": {
    "title": "File",
    "content": "File . Authelia supports a file as a users database. . Configuration . Configuring Authelia to use a file is done by specifying the path to the file in the configuration file. . authentication_backend: disable_reset_password: false file: path: /var/lib/authelia/users.yml password: algorithm: argon2id iterations: 1 salt_length: 16 parallelism: 8 memory: 1024 . Format . The format of the users file is as follows. . users: john: password: &quot;$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM&quot; email: john.doe@authelia.com groups: - admins - dev harry: password: &quot;$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM&quot; email: harry.potter@authelia.com groups: [] bob: password: &quot;$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM&quot; email: bob.dylan@authelia.com groups: - dev james: password: &quot;$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM&quot; email: james.dean@authelia.com . This file should be set with read/write permissions as it could be updated by users resetting their passwords. . Passwords . The file contains hashed passwords instead of plain text passwords for security reasons. . You can use Authelia binary or docker image to generate the hash of any password. The hash-password command has many tunable options, you can view them with the authelia hash-password --help command. For example if you wanted to improve the entropy you could generate a 16 byte salt and provide it with the --salt flag. Example: authelia hash-password --salt abcdefghijklhijl. For argon2id the salt must always be valid for base64 decoding (characters a through z, A through Z, 0 through 9, and +/). . For instance to generate a hash with the docker image just run: . $ docker run authelia/authelia:latest authelia hash-password yourpassword Password hash: $argon2id$v=19$m=65536$3oc26byQuSkQqksq$zM1QiTvVPrMfV6BVLs2t4gM+af5IN7euO0VB6+Q8ZFs . Full CLI Help Documentation: . Hash a password to be used in file-based users database. Default algorithm is argon2id. Usage: authelia hash-password [password] [flags] Flags: -h, --help help for hash-password -i, --iterations int set the number of hashing iterations (default 1) -k, --key-length int [argon2id] set the key length param (default 32) -m, --memory int [argon2id] set the amount of memory param (in MB) (default 1024) -p, --parallelism int [argon2id] set the parallelism param (default 8) -s, --salt string set the salt string -l, --salt-length int set the auto-generated salt length (default 16) -z, --sha512 use sha512 as the algorithm (defaults iterations to 50000, change with -i) . Password hash algorithm . The default hash algorithm is Argon2id version 19 with a salt. Argon2id is currently considered the best hashing algorithm, and in 2015 won the Password Hashing Competition. It benefits from customizable parameters allowing the cost of computing a hash to scale into the future which makes it harder to brute-force. Argon2id was implemented due to community feedback as you can see in this closed issue. . For backwards compatibility and user choice support for the SHA512 algorithm is still available. While it’s a reasonable hashing function given high enough iterations, as hardware improves it has a higher chance of being brute-forced. . Hashes are identifiable as argon2id or SHA512 by their prefix of either $argon2id$ and $6$ respectively, as described in this wiki page. . Important Note: When using argon2id Authelia will appear to remain using the memory allocated to creating the hash. This is due to how Go allocates memory to the heap when generating an argon2id hash. Go periodically garbage collects the heap, however this doesn’t remove the memory allocation, it keeps it allocated even though it’s technically unused. Under memory pressure the unused allocated memory will be reclaimed by the operating system, you can test this on linux with: . $ stress-ng --vm-bytes $(awk &#39;/MemFree/{printf &quot;%d n&quot;, $2 * 0.9;}&#39; &lt; /proc/meminfo)k --vm-keep -m 1 . If this is not desirable we recommend investigating the following options in order of most to least secure: . using the LDAP authentication provider | adjusting the memory parameter | changing the algorithm | Password hash algorithm tuning . All algorithm tuning for Argon2id is supported. The only configuration variables that affect SHA512 are iterations and salt length. The configuration variables are unique to the file authentication provider, thus they all exist in a key under the file authentication configuration key called password. We have set what are considered as sane and recommended defaults to cater for a reasonable system, if you’re unsure about which settings to tune, please see the parameters below, or for a more in depth understanding see the referenced documentation in Argon2 links. . Password hashing configuration settings . algorithm . Value Type: String | Possible Value: argon2id or sha512 | Recommended: argon2id | What it Does: Changes the hashing algorithm | . iterations . Value Type: Int | Possible Value: 1 or higher for argon2id and 1000 or higher for sha512 (will automatically be set to 1000 on lower settings) | Recommended: 1 for the argon2id algorithm and 50000 for sha512 | What it Does: Adjusts the number of times we run the password through the hashing algorithm | . key_length . Value Type: Int | Possible Value: 16 or higher. | Recommended: 32 or higher. | What it Does: Adjusts the length of the actual hash | . salt_length . Value Type: Int | Possible Value: between 2 and 16 | Recommended: 16 | What it Does: Adjusts the length of the random salt we add to the password, there is no reason not to set this to 16 | . parallelism . Value Type: Int | Possible Value: 1 or higher | Recommended: 8 or twice your CPU cores | What it Does: Sets the number of threads used for hashing | . memory . Value Type: Int | Possible Value: at least 8 times the value of parallelism | Recommended: 1024‬‬ (1GB) or as much RAM as you can afford to give to hashing | What it Does: Sets the amount of RAM used in MB for hashing | . Examples for specific systems . These examples have been tested against a single system to make sure they roughly take 0.5 seconds each. Your results may vary depending on individual specification and utilization, but they are a good guide to get started. You should however read the linked documents in Argon2 links. . System Iterations Parallelism Memory . Raspberry Pi 2 | 1 | 8 | 64 | . Raspberry Pi 3 | 1 | 8 | 128 | . Raspberry Pi 4 | 1 | 8 | 128 | . Intel G5 i5 NUC | 1 | 8 | 1024 | . Argon2 Links . How to choose the right parameters for Argon2 . Go Documentation . IETF Draft .",
    "url": "https://docs.authelia.com/configuration/authentication/file.html",
    "relUrl": "/configuration/authentication/file.html"
  }
  ,"11": {
    "title": "Filesystem",
    "content": "Filesystem . With this configuration, the message will be sent to a file. This option should only be used for testing purposes. . # Configuration of the notification system. # # Notifications are sent to users when they require a password reset, a U2F # registration or a TOTP registration. # Use only an available configuration: filesystem, smtp. notifier: # You can disable the notifier startup check by setting this to true. disable_startup_check: false # For testing purpose, notifications can be sent in a file. filesystem: filename: /tmp/authelia/notification.txt .",
    "url": "https://docs.authelia.com/configuration/notifier/filesystem.html",
    "relUrl": "/configuration/notifier/filesystem.html"
  }
  ,"12": {
    "title": "First Factor",
    "content": "First Factor . 2-Factor authentication is a method in which a user is granted access by presenting two pieces of evidence that she is who she claims to be. . Authelia requires usual username and password as a first factor. . . IMPORTANT: This is the only method available as first factor. . Authelia supports several kind of users databases: . An LDAP server like OpenLDAP or OpenAM. | An Active Directory. | A YAML file | .",
    "url": "https://docs.authelia.com/features/first-factor.html",
    "relUrl": "/features/first-factor.html"
  }
  ,"13": {
    "title": "Getting Started",
    "content": "Getting Started . Docker Compose . Steps . These commands are intended to be run sequentially: . git clone https://github.com/authelia/authelia.git | cd authelia/compose/local | sudo ./setup.sh sudo is required to modify the /etc/hosts file | . You can now visit the following locations; replace example.com with the domain you specified in the setup script: . https://public.example.com - Bypasses Authelia | https://traefik.example.com - Secured with Authelia one-factor authentication | https://secure.example.com - Secured with Authelia two-factor authentication (see note below) | . You will need to authorize the self-signed certificate upon visiting each domain. To visit https://secure.example.com you will need to register a device for second factor authentication and confirm by clicking on a link sent by email. Since this is a demo with a fake email address, the content of the email will be stored in ./authelia/notification.txt. Upon registering, you can grab this link easily by running the following command: grep -Eo &#39;&quot;https://.*&quot; &#39; ./authelia/notification.txt. . Deployment . So you’re convinced that Authelia is what you need. You can head to the deployment documentation here. Some recipes have been crafted for helping with the bootstrap of your environment. You can choose between a lite deployment which is deployment advised for a single server setup. However, this setup just does not scale. If you want a full environment that can scale out, use the HA or Kubernetes deployment documentation. .",
    "url": "https://docs.authelia.com/getting-started.html",
    "relUrl": "/getting-started.html"
  }
  ,"14": {
    "title": "Google Analytics",
    "content": "Google Analytics . It is possible to provide a Google Analytics ID to Authelia in order to monitor the usage of the Sign-In portal. . google_analytics: UA-00000-01 .",
    "url": "https://docs.authelia.com/configuration/google-analytics.html",
    "relUrl": "/configuration/google-analytics.html"
  }
  ,"15": {
    "title": "HAProxy",
    "content": "HAProxy . HAProxy is a reverse proxy supported by Authelia. . Requirements . You need the following to run Authelia with HAProxy: . HAProxy 1.8.4+ USE_LUA=1 set at compile time | . | haproxy-auth-request | LuaSocket with commit 0b03eec16b (that is: newer than 2014-11-10) in your Lua library path (LUA_PATH) lua-socket from Debian Stretch works | lua-socket from Ubuntu Xenial works | lua-socket from Ubuntu Bionic works | lua5.3-socket from Alpine 3.8 works | luasocket from luarocks does not work | lua-socket v3.0.0.17.rc1 from EPEL does not work | lua-socket from Fedora 28 does not work | . | . Configuration . Below you will find commented examples of the following configuration: . Authelia portal | Protected endpoint (Nextcloud) | haproxy-auth-request | . With this configuration you can protect your virtual hosts with Authelia, by following the steps below: . Add host(s) to the protected-frontends ACL to support protection with Authelia. You can separate each subdomain with a | in the regex, for example: acl protected-frontends hdr(host) -m reg -i ^(jenkins|nextcloud|phpmyadmin) .example .com . | Add host ACL(s) in the form of host-service, this will be utilised to route to the correct backend upon successful authentication, for example: acl host-jenkins hdr(host) -i jenkins.example.com acl host-jenkins hdr(host) -i nextcloud.example.com acl host-phpmyadmin hdr(host) -i phpmyadmin.example.com . | Add backend route for your service(s), for example: use_backend be_jenkins if host-jenkins use_backend be_nextcloud if host-nextcloud use_backend be_phpmyadmin if host-phpmyadmin . | Add backend definitions for your service(s), for example: backend be_jenkins server jenkins jenkins:8080 backend be_nextcloud server nextcloud nextcloud:443 ssl verify none backend be_phpmyadmin server phpmyadmin phpmyadmin:80 . | Secure Authelia with TLS . There is a known limitation with haproxy-auth-request with regard to TLS-enabled backends. If you want to run Authelia TLS enabled the recommended workaround utilises HAProxy itself to proxy the requests. This comes at a cost of two additional TCP connections, but allows the full HAProxy configuration flexbility with regard to TLS verification as well as header rewriting. An example of this configuration is also be provided below. . Configuration . haproxy.cfg . global # Path to haproxy-auth-request lua-load /usr/local/etc/haproxy/auth-request.lua log stdout format raw local0 debug defaults mode http log global option httplog option forwardfor frontend fe_http bind *:443 ssl crt /usr/local/etc/haproxy/haproxy.pem # Host ACLs acl protected-frontends hdr(host) -m reg -i ^(nextcloud) .example .com acl host-authelia hdr(host) -i auth.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com http-request set-var(req.scheme) str(https) if { ssl_fc } http-request set-var(req.scheme) str(http) if !{ ssl_fc } http-request set-var(req.questionmark) str(?) if { query -m found } # Headers to construct redirection URL http-request set-header X-Real-IP %[src] http-request set-header X-Forwarded-Proto %[var(req.scheme)] http-request set-header X-Forwarded-Host %[req.hdr(Host)] http-request add-header X-Forwarded-Port %[dst_port] http-request set-header X-Forwarded-Uri %[path]%[var(req.questionmark)]%[query] # Protect endpoints with haproxy-auth-request and Authelia http-request lua.auth-request be_authelia /api/verify if protected-frontends # Authelia backend route use_backend be_authelia if host-authelia # Redirect protected-frontends to Authelia if not authenticated use_backend be_authelia if protected-frontends !{ var(txn.auth_response_successful) -m bool } # Service backend route(s) use_backend be_nextcloud if host-nextcloud backend be_authelia server authelia authelia:9091 backend be_nextcloud server nextcloud nextcloud:443 ssl verify none . haproxy.cfg (TLS enabled Authelia) . global # Path to haproxy-auth-request lua-load /usr/local/etc/haproxy/auth-request.lua log stdout format raw local0 debug defaults mode http log global option httplog option forwardfor frontend fe_http bind *:443 ssl crt /usr/local/etc/haproxy/haproxy.pem # Host ACLs acl protected-frontends hdr(host) -m reg -i ^(nextcloud) .example .com acl host-authelia hdr(host) -i auth.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com http-request set-var(req.scheme) str(https) if { ssl_fc } http-request set-var(req.scheme) str(http) if !{ ssl_fc } http-request set-var(req.questionmark) str(?) if { query -m found } # Headers to construct redirection URL http-request set-header X-Real-IP %[src] http-request set-header X-Forwarded-Proto %[var(req.scheme)] http-request set-header X-Forwarded-Host %[req.hdr(Host)] http-request add-header X-Forwarded-Port %[dst_port] http-request set-header X-Forwarded-Uri %[path]%[var(req.questionmark)]%[query] # Protect endpoints with haproxy-auth-request and Authelia http-request lua.auth-request be_authelia_proxy /api/verify if protected-frontends # Authelia backend route use_backend be_authelia if host-authelia # Redirect protected-frontends to Authelia if not authenticated use_backend be_authelia if protected-frontends !{ var(txn.auth_response_successful) -m bool } # Service backend route(s) use_backend be_nextcloud if host-nextcloud backend be_authelia server authelia authelia:9091 backend be_authelia_proxy mode http server proxy 127.0.0.1:9092 listen authelia_proxy mode http bind 127.0.0.1:9092 server authelia authelia:9091 ssl verify none backend be_nextcloud server nextcloud nextcloud:443 ssl verify none .",
    "url": "https://docs.authelia.com/deployment/supported-proxies/haproxy.html",
    "relUrl": "/deployment/supported-proxies/haproxy.html"
  }
  ,"16": {
    "title": "Configuration",
    "content": "Configuration . Authelia uses a YAML file as configuration file. A template with all possible options can be found here, at the root of the repository. . When running Authelia, you can specify your configuration by passing the file path as shown below. . $ authelia --config config.custom.yml . Validation . Authelia validates the configuration when it starts. This process checks multiple factors including configuration keys that don’t exist, configuration keys that have changed, the values of the keys are valid, and that a configuration key isn’t supplied at the same time as a secret for the same configuration option. . You may also optionally validate your configuration against this validation process manually by using the validate-config option with the Authelia binary as shown below. Keep in mind if you’re using secrets you will have to manually provide these if you don’t want to get certain validation errors (specifically requesting you provide one of the secret values). You can choose to ignore them if you know what you’re doing. This command is useful prior to upgrading to prevent configuration changes from impacting downtime in an upgrade. . $ authelia validate-config configuration.yml . Duration Notation Format . We have implemented a string based notation for configuration options that take a duration. This section describes its usage. You can use this implementation in: session for expiration, inactivity, and remember_me_duration; and regulation for ban_time, and find_time. This notation also supports just providing the number of seconds instead. . The notation is comprised of a number which must be positive and not have leading zeros, followed by a letter denoting the unit of time measurement. The table below describes the units of time and the associated letter. . Unit Associated Letter . Years | y | . Months | M | . Weeks | w | . Days | d | . Hours | h | . Minutes | m | . Seconds | s | . Examples: . 1 hour and 30 minutes: 90m | 1 day: 1d | 10 hours: 10h | .",
    "url": "https://docs.authelia.com/configuration/",
    "relUrl": "/configuration/"
  }
  ,"17": {
    "title": "Home",
    "content": "Home . It has never been so easy to secure your applications with Single Sign-On and Two-Factor. . With Authelia you can login once and get access to all your web apps safely from the Web thanks to two-factor authentication. . . Authelia is an open source authentication and authorization server protecting modern web applications by collaborating with reverse proxies such as NGINX, Traefik and HAProxy. Consequently, no code is required to protect your apps. . . Multiple 2-factor methods are available for satisfying every users. . Time-based One-Time passwords with Google Authenticator. | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . Authelia is available as Docker images, static binaries and AUR packages so that you can test it in minutes. Let’s begin with the Getting Started. . However, Authelia… . is not an OAuth or OpenID Connect provider yet. | is not a SAML provider yet. | does not support authentication against an OAuth or OpenID Connect provider yet. | does not support authentication against a SAML provider yet. | does not support using hardware devices as single factor. | does not provide a PAM module yet. | .",
    "url": "https://docs.authelia.com/",
    "relUrl": "/"
  }
  ,"18": {
    "title": "Notifier",
    "content": "Notifier . Authelia sometimes needs to send messages to users in order to verify their identity. . Startup Check . The notifier has a startup check which validates the specified provider configuration is correct and will be able to send emails. This can be disabled with the disable_startup_check option: . # Configuration of the notification system. # # Notifications are sent to users when they require a password reset, a u2f # registration or a TOTP registration. # Use only an available configuration: filesystem, smtp. notifier: # You can disable the notifier startup check by setting this to true disable_startup_check: false .",
    "url": "https://docs.authelia.com/configuration/notifier/",
    "relUrl": "/configuration/notifier/"
  }
  ,"19": {
    "title": "Contributing",
    "content": "Contributing . Development workflow . Authelia and its development workflow can be tested with Docker and docker-compose on Linux. . In order to deploy the current version of Authelia locally, run the following command and follow the instructions of bootstrap.sh: . $ source bootstrap.sh . Then, start the Standalone suite. . $ authelia-scripts suites setup Standalone . A suite is kind of a virtual environment for running Authelia in a complete ecosystem. If you want more details please read the related documentation. . FAQ . What version of Docker and docker-compose should I use? . Here are the versions used for testing in Buildkite: . $ docker --version Docker version 19.03.5, build 633a0ea838 $ docker-compose --version docker-compose version 1.24.1, build unknown . How can I serve my application under example.com? . Don’t worry, you don’t need to own the domain example.com to test Authelia. Copy the following lines in your /etc/hosts. . 192.168.240.100 home.example.com 192.168.240.100 login.example.com 192.168.240.100 singlefactor.example.com 192.168.240.100 public.example.com 192.168.240.100 secure.example.com 192.168.240.100 mail.example.com 192.168.240.100 mx1.mail.example.com . 192.168.240.100 is the IP attributed by Docker to the reverse proxy. Once done you can access the listed sub-domains from your browser and they will target the reverse proxy. .",
    "url": "https://docs.authelia.com/contributing/",
    "relUrl": "/contributing/"
  }
  ,"20": {
    "title": "Deployment",
    "content": "Deployment .",
    "url": "https://docs.authelia.com/deployment/",
    "relUrl": "/deployment/"
  }
  ,"21": {
    "title": "Authentication backends",
    "content": "Authentication Backends . There are two ways to store the users along with their password: . LDAP: users are stored in remote servers like OpenLDAP, OpenAM or Microsoft Active Directory. | File: users are stored in YAML file with a hashed version of their password. | . Disabling Reset Password . You can disable the reset password functionality for additional security as per this configuration: . # The authentication backend to use for verifying user passwords # and retrieve information such as email address and groups # users belong to. # # There are two supported backends: &#39;ldap&#39; and &#39;file&#39;. authentication_backend: # Disable both the HTML element and the API for reset password functionality disable_reset_password: true .",
    "url": "https://docs.authelia.com/configuration/authentication/",
    "relUrl": "/configuration/authentication/"
  }
  ,"22": {
    "title": "Proxy Integration",
    "content": "Integration with proxies . Authelia works in collaboration with reverse proxies. In the sub-pages you can find the documentation of the configuration required for every supported proxy. . If you are not aware of the workflow of an authentication request, reading this documentation first is highly recommended. . How Authelia integrates with proxies? . Authelia takes authentication requests coming from the proxy and targeting the /api/verify endpoint exposed by Authelia. Two pieces of information are required for Authelia to be able to authenticate the user request: . The session cookie or a Proxy-Authorization header (see single factor authentication). | The target URL of the user request (used primarily for access control). | . The target URL can be provided using one of the following ways: . With X-Original-URL header containing the complete URL of the initial request. | With a combination of X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-URI headers. | . In the case of Traefik, these headers are automatically provided and therefore don’t appear in the configuration examples. . How can the backend be aware of the authenticated users? . The only way Authelia can share information about the authenticated user currently is through the use of two HTTP headers: Remote-User and Remote-Groups. Those headers are returned by Authelia on requests to /api/verify and must be forwarded by the reverse proxy to the backends needing them. Please note that the backend must support the use of those headers to leverage that information, many backends still don’t (and probably won’t) support it. However, we are working on solving this issue with OpenID Connect/OAuth2 which is a widely adopted open standard for access delegation. . So, if you’re developing your own application, you can read those headers and use them. If you don’t own the codebase of the backend, you need to check whether it supports this type of authentication or not. If it does not, you have three options: . Enable authentication on the backend and make your users authenticate twice (not user-friendly). | Completely disable the authentication of your backend. This works only if all your users share the same privileges in the backend. | Many applications support OAuth2 so the last option would be to just wait for Authelia to be an OpenID Connect provider (https://github.com/authelia/authelia/issues/189). | Redirection to the login portal . The endpoint /api/verify has different behaviors depending on whether the rd (for redirection) query parameter is provided. . If redirection parameter is provided and contains the URL to the login portal served by Authelia, the request will either generate a 200 response if the request is authenticated or perform a redirection (302 response) to the login portal if not authenticated yet. . If no redirection parameter is provided, the response code is either 200 or 401. The redirection must then be handled by the proxy when an error is detected (see nginx example). .",
    "url": "https://docs.authelia.com/deployment/supported-proxies/",
    "relUrl": "/deployment/supported-proxies/"
  }
  ,"23": {
    "title": "Community",
    "content": "Community documentation . This section is meant to advertise and organize documentation produced by the community. This documentation is considered non-official and we will not guarantee that this documentation is up-to-date. If you think some of it should be considered official, please file an issue on Github. .",
    "url": "https://docs.authelia.com/community/",
    "relUrl": "/community/"
  }
  ,"24": {
    "title": "Security",
    "content": "Security . Authelia takes security very seriously. We follow the rule of responsible disclosure, and we encourage the community to as well. . If you discover a vulnerability in Authelia, please first contact clems4ever on Matrix or by email. .",
    "url": "https://docs.authelia.com/security/",
    "relUrl": "/security/"
  }
  ,"25": {
    "title": "Storage backends",
    "content": "Storage backends . Authelia supports multiple storage backends. The backend is used to store user preferences, 2FA device handles and secrets, authentication logs, etc… . The available options are: . MariaDB | MySQL | Postgres | SQLite | .",
    "url": "https://docs.authelia.com/configuration/storage/",
    "relUrl": "/configuration/storage/"
  }
  ,"26": {
    "title": "Second Factor",
    "content": "Second Factor . There are multiple supported options for the second factor. . Time-based One-Time passwords with Google Authenticator | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . .",
    "url": "https://docs.authelia.com/features/2fa/",
    "relUrl": "/features/2fa/"
  }
  ,"27": {
    "title": "Features",
    "content": "Features . Authelia is a 2FA &amp; SSO authentication server which is dedicated to the security of applications and users. It can be considered as an extension of reverse proxies by providing features specific to authentication. You will find among other features: . Multiple two-factor methods. | Identity verification when registering second factor devices. | Reset password. | Ban account after too many attempts (known as regulation). | .",
    "url": "https://docs.authelia.com/features/",
    "relUrl": "/features/"
  }
  ,"28": {
    "title": "LDAP",
    "content": "LDAP . Authelia supports using a LDAP server as the users database. . Configuration . Configuration of the LDAP backend is done as follows . authentication_backend: disable_reset_password: false ldap: # The url to the ldap server. Scheme can be ldap:// or ldaps:// url: ldap://127.0.0.1 # Skip verifying the server certificate (to allow self-signed certificate). skip_verify: false # The base dn for every entries base_dn: dc=example,dc=com # The attribute holding the username of the user. This attribute is used to populate # the username in the session information. It was introduced due to #561 to handle case # insensitive search queries. # For you information, Microsoft Active Directory usually uses &#39;sAMAccountName&#39; and OpenLDAP # usually uses &#39;uid&#39; # Beware that this attribute holds the unique identifiers for the users binding the user and the configuration # stored in database. Therefore only single value attributes are allowed and the value # must never be changed once attributed to a user otherwise it would break the configuration # for that user. Technically, non-unique attributes like &#39;mail&#39; can also be used but we don&#39;t recommend using # them, we instead advise to use the attributes mentioned above (sAMAccountName and uid) to follow # https://www.ietf.org/rfc/rfc2307.txt. username_attribute: uid # An additional dn to define the scope to all users additional_users_dn: ou=users # The users filter used in search queries to find the user profile based on input filled in login form. # Various placeholders are available to represent the user input and back reference other options of the configuration: # - {input} is a placeholder replaced by what the user inputs in the login form. # - {username_attribute} is a placeholder replaced by what is configured in `username_attribute`. # - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`. # - DON&#39;T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later versions, so please don&#39;t use it. # # Recommended settings are as follows: # - Microsoft Active Directory: (&amp;({username_attribute}={input})(objectCategory=person)(objectClass=user)) # - OpenLDAP: (&amp;({username_attribute}={input})(objectClass=person))&#39; or &#39;(&amp;({username_attribute}={input})(objectClass=inetOrgPerson)) # # To allow sign in both with username and email, one can use a filter like # (&amp;(|({username_attribute}={input})({mail_attribute}={input}))(objectClass=person)) users_filter: (&amp;({username_attribute}={input})(objectClass=person)) # An additional dn to define the scope of groups additional_groups_dn: ou=groups # The groups filter used in search queries to find the groups of the user. # - {input} is a placeholder replaced by what the user inputs in the login form. # - {username} is a placeholder replace by the username stored in LDAP (based on `username_attribute`). # - {dn} is a matcher replaced by the user distinguished name, aka, user DN. # - {username_attribute} is a placeholder replaced by what is configured in `username_attribute`. # - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`. # - DON&#39;T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later versions, so please don&#39;t use it. # - DON&#39;T USE - {1} is an alias for {username} supported for backward compatibility but it will be deprecated in later version, so please don&#39;t use it. groups_filter: (&amp;(member={dn})(objectclass=groupOfNames)) # The attribute holding the name of the group group_name_attribute: cn # The attribute holding the mail address of the user mail_attribute: mail # The username and password of the admin user. If multiple email addresses are defined for a user, only the first # one returned by the LDAP server is used. user: cn=admin,dc=example,dc=com # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: password . The user must have an email address in order for Authelia to perform identity verification when a user attempts to reset their password or register a second factor device. . Important notes . Users must be uniquely identified by an attribute, this attribute must obviously contain a single value and be guaranteed by the administrator to be unique. If multiple users have the same value, Authelia will simply fail authenticating the user and display an error message in the logs. . In order to avoid such problems, we highly recommended you follow https://www.ietf.org/rfc/rfc2307.txt by using sAMAccountName for Microsoft Active Directory and uid for other implementations as the attribute holding the unique identifier for your users. . Loading a password from a secret instead of inside the configuration . Password can also be defined using a secret. .",
    "url": "https://docs.authelia.com/configuration/authentication/ldap.html",
    "relUrl": "/configuration/authentication/ldap.html"
  }
  ,"29": {
    "title": "MariaDB",
    "content": "MariaDB . storage: mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: mypassword . Loading a password from a secret instead of inside the configuration . Password can also be defined using a secret. .",
    "url": "https://docs.authelia.com/configuration/storage/mariadb.html",
    "relUrl": "/configuration/storage/mariadb.html"
  }
  ,"30": {
    "title": "Security Measures",
    "content": "Security Measures . Protection against cookie theft . Authelia uses two mechanisms to protect against cookie theft: . session attribute httpOnly set to true make client-side code unable to read the cookie. | session attribute secure ensure the cookie will never be sent over an insecure HTTP connections. | Protection against multi-domain cookie attacks . Since Authelia uses multi-domain cookies to perform single sign-on, an attacker who poisoned a user’s DNS cache can easily retrieve the user’s cookies by making the user send a request to one of the attacker’s IPs. . To mitigate this risk, it’s advisable to only use HTTPS connections with valid certificates and enforce it with HTTP Strict Transport Security (HSTS) so that the attacker must also require the certificate to retrieve the cookies. . Note that using HSTS has consequences. That’s why you should read the blog post nginx has written on HSTS. . Protections against password cracking (File authentication provider) . Authelia implements a variety of measures to prevent an attacker cracking passwords if they somehow obtain the file used by the file authentication provider, this is unrelated to LDAP auth. . First and foremost Authelia only uses very secure hashing algorithms with sane and secure defaults. The first and default hashing algorithm we use is Argon2id which is currently considered the most secure hashing algorithm. We also support SHA512, which previously was the default. . Secondly Authelia uses salting with all hashing algorithms. These salts are generated with a random string generator, which is seeded every time it’s used by a cryptographically secure 1024bit prime number. This ensures that even if an attacker obtains the file, each password has to be brute forced individually. . Lastly Authelia’s implementation of Argon2id is highly tunable. You can tune the key length, salt used, iterations (time), parallelism, and memory usage. To read more about this please read how to configure file authentication. . Notifier security measures (SMTP) . By default the SMTP Notifier implementation does not allow connections that are not secure. As such all connections require the following: . TLS Connection (STARTTLS or SMTPS) has been negotiated before authentication or sending emails (unauthenticated connections require it as well) | Valid X509 Certificate presented to the client during the TLS handshake | There is an option to disable both of these security measures however they are not recommended. You should only do this in a situation where you control all networks between Authelia and the SMTP server. The following configuration options exist to configure the security level: . SMTPS vs STARTTLS . By default all connections start as plain text and are upgraded via STARTTLS. SMTPS is supported, however due to the fact it was basically considered deprecated before the turn of the century, there is no way to configure it. It happens automatically when a SMTP notifier is configured with the SMTPS port of 465. . Configuration Option: disable_verify_cert . This is a YAML boolean type (true/false, y/n, 1/0, etc). This disables the X509 PKI verification mechanism. We recommend using the trusted_cert option over this, as disabling this security feature makes you vulnerable to MITM attacks. . Configuration Option: disable_require_tls . This is a YAML boolean type (true/false, y/n, 1/0, etc). This disables the requirement that all connections must be over TLS. This is only usable currently with authentication disabled (comment the password) and as such is only an option for SMTP servers that allow unauthenticated relay (bad practice). . Configuration Option: trusted_cert . This is a YAML string type. This specifies the file location of a pub certificate that can be used to validate the authenticity of a server with a self signed certificate. This can either be the public cert of the certificate authority used to sign the certificate or the public key itself. They must be in the PEM format. The certificate is added in addition to the certificates trusted by the host machine. If the certificate is invalid, inaccessible, or is otherwise not configured; Authelia just uses the hosts certificates. . Explanation . There are a few reasons for the security measures implemented: . Transmitting username’s and passwords over plain-text is an obvious vulnerability | The emails generated by Authelia, if transmitted in plain-text could allow an attacker to intercept a link used to setup 2FA; which reduces security | Not validating the identity of the server allows man-in-the-middle attacks | Additional security . Reset Password . It’s possible to disable the reset password functionality and is recommended for anyone wanting to increase security. See the configuration for information. . Session security . We have a few options to configure the security of a session. The main and most important one is the session secret. This is used to encrypt the session data when when stored in the Redis key value database. This should be as random as possible. . Additionally you can configure the validity period of sessions. For example in a highly security conscious domain you would probably want to set the session remember_me_duration to 0 to disable this feature, and set an expiration of something like 2 hours and inactivity of 10 minutes. This means the hard limit or the time the session will be destroyed no matter what is 2 hours, and the soft limit or the time a user can be inactive for is 10 minutes. . More protections measures with Nginx . You can also apply the following headers to your nginx configuration for improving security. Please read the documentation of those headers before applying them blindly. . # We don&#39;t want any credentials / TOTP secret key / QR code to be cached by # the client add_header Cache-Control &quot;no-store&quot;; add_header Pragma &quot;no-cache&quot;; # Clickjacking / XSS protection # We don&#39;t want Authelia&#39;s login page to be rendered within a &lt;frame&gt;, # &lt;iframe&gt; or &lt;object&gt; from an external website. add_header X-Frame-Options &quot;SAMEORIGIN&quot;; # Block pages from loading when they detect reflected XSS attacks. add_header X-XSS-Protection &quot;1; mode=block&quot;; .",
    "url": "https://docs.authelia.com/security/measures.html",
    "relUrl": "/security/measures.html"
  }
  ,"31": {
    "title": "Miscellaneous",
    "content": "Miscellaneous . Here are the main customizable options in Authelia. . Host &amp; Port . optional: true . Defines the address and port to listen on. . host: 0.0.0.0 port: 9091 . TLS . optional: true . Authelia can use TLS. Provide the certificate and the key with the following configuration options: . tls_key: /var/lib/authelia/ssl/key.pem tls_cert: /var/lib/authelia/ssl/cert.pem . Log . Log level . optional: true . Defines the level of logs used by Authelia. This level can be set to trace, debug or info. When setting log_level to trace, you will generate a large amount of log entries and expose the /debug/vars and /debug/pprof/ endpoints which should not be enabled in production. . log_level: debug . Log file path . optional: true . Logs can be stored in a file when file path is provided. Otherwise logs are written to standard output. . log_file_path: /var/log/authelia.log . JWT Secret . optional: false . Defines the secret used to craft JWT tokens leveraged by the identity verification process. This can also be defined using a secret. . jwt_secret: v3ry_important_s3cr3t . Default redirection URL . optional: true . The default redirection URL is the URL where users are redirected when Authelia cannot detect the target URL where the user was heading. . In a normal authentication workflow, a user tries to access a website and she gets redirected to the sign-in portal in order to authenticate. Since the user initially targeted a website, the portal knows where the user was heading and can redirect her after the authentication process. However, when a user visits the sign in portal directly, the portal considers the targeted website is the portal. In that case and if the default redirection URL is configured, the user is redirected to that URL. If not defined, the user is not redirected after authentication. .",
    "url": "https://docs.authelia.com/configuration/miscellaneous.html",
    "relUrl": "/configuration/miscellaneous.html"
  }
  ,"32": {
    "title": "MySQL",
    "content": "MySQL . storage: mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: mypassword . Loading a password from a secret instead of inside the configuration . Password can also be defined using a secret. .",
    "url": "https://docs.authelia.com/configuration/storage/mysql.html",
    "relUrl": "/configuration/storage/mysql.html"
  }
  ,"33": {
    "title": "Nginx",
    "content": "Nginx . nginx is a reverse proxy supported by Authelia. . Configuration . Below you will find commented examples of the following configuration: . Authelia portal | Protected endpoint (Nextcloud) | Supplementary config | . With the below configuration you can add authelia.conf to virtual hosts to support protection with Authelia. auth.conf is utilised to enable the protection either at the root location or a more specific location/route. proxy.conf is included just for completeness. . Supplementary config . authelia.conf . # Virtual endpoint created by nginx to forward auth requests. location /authelia { internal; set $upstream_authelia http://authelia:9091/api/verify; proxy_pass_request_body off; proxy_pass $upstream_authelia; proxy_set_header Content-Length &quot;&quot;; # Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # [REQUIRED] Needed by Authelia to check authorizations of the resource. # Provide either X-Original-URL and X-Forwarded-Proto or # X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-Uri or both. # Those headers will be used by Authelia to deduce the target url of the user. # Basic Proxy Config client_body_buffer_size 128k; proxy_set_header Host $host; proxy_set_header X-Original-URL $scheme://$http_host$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 4 32k; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 240; proxy_send_timeout 240; proxy_connect_timeout 240; } . auth.conf . # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it&#39;s gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; # If Authelia returns 401, then nginx redirects the user to the login portal. # If it returns 200, then the request pass through to the backend. # For other type of errors, nginx will handle them as usual. error_page 401 =302 https://auth.example.com/?rd=$target_url; . proxy.conf . client_body_buffer_size 128k; #Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 360; proxy_send_timeout 360; proxy_connect_timeout 360; # Basic Proxy Config proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 64 256k; # If behind reverse proxy, forwards the correct IP set_real_ip_from 10.0.0.0/8; set_real_ip_from 172.0.0.0/8; set_real_ip_from 192.168.0.0/16; set_real_ip_from fc00::/7; real_ip_header X-Forwarded-For; real_ip_recursive on; . Authelia Portal . server { server_name auth.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name auth.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; location / { set $upstream_authelia http://authelia:9091; # This example assumes a Docker deployment proxy_pass $upstream_authelia; include /config/nginx/proxy.conf; # } } . Protected Endpoint . server { server_name nextcloud.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name nextcloud.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; include /config/nginx/authelia.conf; # Virtual endpoint to forward auth requests location / { set $upstream_nextcloud https://nextcloud; proxy_pass $upstream_nextcloud; include /config/nginx/auth.conf; # Activates Authelia for specified route/location, please ensure you have setup the domain in your configuration.yml include /config/nginx/proxy.conf; # Reverse proxy configuration } } .",
    "url": "https://docs.authelia.com/deployment/supported-proxies/nginx.html",
    "relUrl": "/deployment/supported-proxies/nginx.html"
  }
  ,"34": {
    "title": "One-Time Password",
    "content": "One-Time Password . Authelia uses time based one-time passwords as the OTP method. You have the option to tune the settings of the TOTP generation and you can see a full example of TOTP configuration below, as well as sections describing them. . totp: issuer: authelia.com period: 30 skew: 1 . Issuer . Applications generating one-time passwords usually display an issuer to differentiate applications registered by the user. . Authelia allows customisation of the issuer to differentiate the entry created by Authelia from others. . Period and Skew . The period and skew configuration parameters affect each other. The default values are a period of 30 and a skew of 1. It is highly recommended you do not change these unless you wish to set skew to 0. . The way you configure these affects security by changing the length of time a one-time password is valid for. The formula to calculate the effective validity period is period + (period * skew * 2). For example period 30 and skew 1 would result in 90 seconds of validity, and period 30 and skew 2 would result in 150 seconds of validity. . Period . Configures the period of time in seconds a one-time password is current for. It is important to note that changing this value will require your users to register their application again. . It is recommended to keep this value set to 30, the minimum is 1. . Skew . Configures the number of one-time passwords either side of the current one that are considered valid, each time you increase this it makes two more one-time passwords valid. For example the default of 1 has a total of 3 keys valid. A value of 2 has 5 one-time passwords valid. . It is recommended to keep this value set to 0 or 1, the minimum is 0. .",
    "url": "https://docs.authelia.com/configuration/one-time-password.html",
    "relUrl": "/configuration/one-time-password.html"
  }
  ,"35": {
    "title": "One-Time Password",
    "content": "Time-based One-Time Password . Authelia supports Time-base one-time password generated by apps like Google Authenticator. . . After having successfully completed the first factor, select One-Time Password method option and click on Not registered yet? link. This will send you an e-mail to confirm your identity. . NOTE: If you’re testing Authelia, this e-mail has likely been sent to the mailbox available at https://mail.example.com:8080/ . Once this validation step is completed, a QRCode gets displayed. . . You can then use Google Authenticator to scan the code in order to register your device. . From now on, you get tokens generated every 30 seconds that you can use to validate the second factor in Authelia. .",
    "url": "https://docs.authelia.com/features/2fa/one-time-password.html",
    "relUrl": "/features/2fa/one-time-password.html"
  }
  ,"36": {
    "title": "Password Reset",
    "content": "Password Reset . Authelia provides a workflow to let users reset their password when they lose it. To disable reset password functionality please see the configuration docs. . A simple click on Reset password? for starting the process. Note that resetting a password requires a new identity verification using the e-mail of the user. . . Give your username and receive an e-mail to verify your identity. . . Once your identity has been verified, fill in the form to reset your password. . . Now you can authenticate with your new credentials. .",
    "url": "https://docs.authelia.com/features/password-reset.html",
    "relUrl": "/features/password-reset.html"
  }
  ,"37": {
    "title": "PostgreSQL",
    "content": "PostgreSQL . storage: postgres: host: 127.0.0.1 port: 5432 database: authelia username: authelia # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: mypassword sslmode: disable . SSL Mode . SSL mode configures how to handle SSL connections with Postgres. Valid options are ‘disable’, ‘require’, ‘verify-ca’, or ‘verify-full’. See the PostgreSQL Documentation or Pure Go Postgres driver Documentation for more information. . Loading a password from a secret instead of inside the configuration . Password can also be defined using a secret. .",
    "url": "https://docs.authelia.com/configuration/storage/postgres.html",
    "relUrl": "/configuration/storage/postgres.html"
  }
  ,"38": {
    "title": "Push Notification",
    "content": "Mobile Push Notification . Mobile push notifications is the new trendy second factor method. When second factor is requested by Authelia, a notification is sent on your phone that you can either accept or deny. . . Authelia leverages Duo third party to provide this feature. . First, sign up on their website, log in, create a user account and attach it a mobile device. Beware that the name of the user must match the name of the user in Authelia. . Then, in Duo interface, click on Applications and Protect an Application. Select the option Partner Auth API. This will generate an integration key, a secret key and a hostname. You can set the name of the application to Authelia and then you must add the generated information to Authelia configuration as shown below: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . Now that Authelia is configured, pass the first factor and select the Push notification option. . . You should now receive a notification on your mobile phone with all the details about the authentication request. . Limitation . Users must be enrolled via the Duo Admin panel, they cannot enroll a device from Authelia yet. . FAQ . Why don’t I have access to the Push Notification option? . It’s likely that you have not configured Authelia correctly. Please read this documentation again and be sure you had a look at config.template.yml. .",
    "url": "https://docs.authelia.com/features/2fa/push-notifications.html",
    "relUrl": "/features/2fa/push-notifications.html"
  }
  ,"39": {
    "title": "Regulation",
    "content": "Regulation . Authelia takes the security of users very seriously and comes with a way to avoid brute-forcing the first factor credentials by regulating the authentication attempts and temporarily banning an account when too many attempts have been made. . Configuration . Please check the dedicated documentation. .",
    "url": "https://docs.authelia.com/features/regulation.html",
    "relUrl": "/features/regulation.html"
  }
  ,"40": {
    "title": "Regulation",
    "content": "Regulation . Authelia can temporarily ban accounts when there are too many authentication attempts. This helps prevent brute-force attacks. . Configuration . regulation: # The number of failed login attempts before user is banned. # Set it to 0 to disable regulation. max_retries: 3 # The time range during which the user can attempt login before being banned. # The user is banned if the authentication failed `max_retries` times in a `find_time` seconds window. # Find Time accepts duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format find_time: 2m # The length of time before a banned user can sign in again. # Find Time accepts duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format ban_time: 5m . Duration Notation . The configuration parameters find_time, and ban_time use duration notation. See the documentation for duration notation format for more information. .",
    "url": "https://docs.authelia.com/configuration/regulation.html",
    "relUrl": "/configuration/regulation.html"
  }
  ,"41": {
    "title": "Secrets",
    "content": "Secrets . Configuration of Authelia requires some secrets and passwords. Even if they can be set in the configuration file, the recommended way to set secrets is to use environment variables as described below. . Environment variables . A secret can be configured using an environment variable with the prefix AUTHELIA_ followed by the path of the option capitalized and with dots replaced by underscores followed by the suffix _FILE. . The contents of the environment variable must be a path to a file containing the secret data. This file must be readable by the user the Authelia daemon is running as. . For instance the LDAP password can be defined in the configuration at the path authentication_backend.ldap.password, so this password could alternatively be set using the environment variable called AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE. . Here is the list of the environment variables which are considered secrets and can be defined. Any other option defined using an environment variable will not be replaced. . Configuration Key Environment Variable . jwt_secret | AUTHELIA_JWT_SECRET_FILE | . duo_api.secret_key | AUTHELIA_DUO_API_SECRET_KEY_FILE | . session.secret | AUTHELIA_SESSION_SECRET_FILE | . session.redis.password | AUTHELIA_SESSION_REDIS_PASSWORD_FILE | . storage.mysql.password | AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE | . storage.postgres.password | AUTHELIA_STORAGE_POSTGRES_PASSWORD_FILE | . notifier.smtp.password | AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE | . authentication_backend.ldap.password | AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE | . Secrets exposed in an environment variable . Prior to implementing file secrets you were able to define the values of secrets in the environment variables themselves in plain text instead of referencing a file. This is still supported but discouraged. If you still want to do this just remove _FILE from the environment variable name and define the value in insecure plain text. See this article for reasons why this is considered insecure and is discouraged. . DEPRECATION NOTICE: This backwards compatibility feature will be removed in 4.18.0+. . Secrets in configuration file . If for some reason you prefer keeping the secrets in the configuration file, be sure to apply the right permissions to the file in order to prevent secret leaks if an another application gets compromised on your server. The UNIX permissions should probably be something like 600. . Docker . Secrets can be provided in a docker-compose.yml either with Docker secrets or bind mounted secret files, examples of these are provided below. . Compose with Docker secrets . This example assumes secrets are stored in /path/to/authelia/secrets/{secretname} on the host and are exposed with Docker secrets in a docker-compose.yml file: . version: &#39;3.8&#39; networks: net: driver: bridge secrets: jwt: file: /path/to/authelia/secrets/jwt duo: file: /path/to/authelia/secrets/duo session: file: /path/to/authelia/secrets/session redis: file: /path/to/authelia/secrets/redis mysql: file: /path/to/authelia/secrets/mysql smtp: file: /path/to/authelia/secrets/smtp ldap: file: /path/to/authelia/secrets/ldap services: authelia: image: authelia/authelia container_name: authelia secrets: - jwt - duo - session - redis - mysql - smtp - ldap volumes: - /path/to/authelia:/var/lib/authelia - /path/to/authelia/configuration.yml:/etc/authelia/configuration.yml:ro networks: - net expose: - 9091 restart: unless-stopped environment: - AUTHELIA_JWT_SECRET_FILE=/run/secrets/jwt - AUTHELIA_DUO_API_SECRET_KEY_FILE=/run/secrets/duo - AUTHELIA_SESSION_SECRET_FILE=/run/secrets/session - AUTHELIA_SESSION_REDIS_PASSWORD_FILE=/run/secrets/redis - AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE=/run/secrets/mysql - AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE=/run/secrets/smtp - AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE=/run/secrets/ldap - TZ=Australia/Melbourne . Compose with bind mounted secret files . This example assumes secrets are stored in /path/to/authelia/secrets/{secretname} on the host and are exposed with bind mounted secret files in a docker-compose.yml file at /etc/authelia/secrets/: . version: &#39;3.8&#39; networks: net: driver: bridge services: authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/var/lib/authelia - /path/to/authelia/configuration.yml:/etc/authelia/configuration.yml:ro - /path/to/authelia/secrets:/etc/authelia/secrets networks: - net expose: - 9091 restart: unless-stopped environment: - AUTHELIA_JWT_SECRET_FILE=/etc/authelia/secrets/jwt - AUTHELIA_DUO_API_SECRET_KEY_FILE=/etc/authelia/secrets/duo - AUTHELIA_SESSION_SECRET_FILE=/etc/authelia/secrets/session - AUTHELIA_SESSION_REDIS_PASSWORD_FILE=/etc/authelia/secrets/redis - AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE=/etc/authelia/secrets/mysql - AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE=/etc/authelia/secrets/smtp - AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE=/etc/authelia/secrets/ldap - TZ=Australia/Melbourne . Kubernetes . Secrets can be mounted as files using the following sample manifests. . Kustomization . Filename: ./kustomization.yaml | Command: kubectl apply -k | Notes: this kustomization expects the Authelia configuration.yml in the same directory. You will need to edit the kustomization.yaml with your desired secrets after the equal signs. If you change the value before the equal sign you’ll have to adjust the volumes section of the daemonset template (or deployment template if you’re using it). | . #filename: ./kustomization.yaml generatorOptions: disableNameSuffixHash: true labels: type: generated app: authelia configMapGenerator: - name: authelia files: - configuration.yml secretGenerator: - name: authelia literals: - jwt_secret=myverysecuresecret - session_secret=mysessionsecret - redis_password=myredispassword - sql_password=mysqlpassword - ldap_password=myldappassword - duo_secret=myduosecretkey - smtp_password=mysmtppassword . DaemonSet . Filename: ./daemonset.yaml | Command: kubectl apply -f ./daemonset.yaml | Notes: assumes Kubernetes API 1.16 or greater #filename: daemonset.yaml #command: kubectl apply -f daemonset.yaml #notes: assumes kubernetes api 1.16+ apiVersion: apps/v1 kind: DaemonSet metadata: name: authelia labels: app: authelia spec: selector: matchLabels: app: authelia updateStrategy: type: RollingUpdate template: metadata: labels: app: authelia spec: containers: - name: authelia image: authelia/authelia:latest imagePullPolicy: IfNotPresent env: - name: AUTHELIA_JWT_SECRET_FILE value: /usr/app/secrets/jwt - name: AUTHELIA_DUO_API_SECRET_KEY_FILE value: /usr/app/secrets/duo - name: AUTHELIA_SESSION_SECRET_FILE value: /usr/app/secrets/session - name: AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE value: /usr/app/secrets/ldap_password - name: AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE value: /usr/app/secrets/smtp_password - name: AUTHELIA_STORAGE_POSTGRES_PASSWORD_FILE value: /usr/app/secrets/sql_password ports: - name: http containerPort: 80 startupProbe: httpGet: path: /api/configuration port: http initialDelaySeconds: 10 timeoutSeconds: 5 periodSeconds: 5 failureThreshold: 4 livenessProbe: httpGet: path: /api/configuration port: http initialDelaySeconds: 60 timeoutSeconds: 5 periodSeconds: 30 failureThreshold: 2 readinessProbe: httpGet: path: /api/configuration port: http initialDelaySeconds: 10 timeoutSeconds: 5 periodSeconds: 5 failureThreshold: 5 volumeMounts: - mountPath: /etc/authelia name: config-volume - mountPath: /usr/app/secrets name: secrets readOnly: true - mountPath: /etc/localtime name: localtime readOnly: true volumes: - name: config-volume configMap: name: authelia items: - key: configuration.yml path: configuration.yml - name: secrets secret: secretName: authelia items: - key: jwt_secret path: jwt - key: duo_secret path: duo - key: session_secret path: session - key: redis_password path: redis_password - key: sql_password path: sql_password - key: ldap_password path: ldap_password - key: smtp_password path: smtp_password - name: localtime hostPath: path: /etc/localtime . | .",
    "url": "https://docs.authelia.com/configuration/secrets.html",
    "relUrl": "/configuration/secrets.html"
  }
  ,"42": {
    "title": "Security Keys",
    "content": "Security Keys . Authelia supports hardware-based second factors leveraging security keys like Yubikeys. . Security keys are among the most secure second factor. This method is already supported by many major applications and platforms like Google, Facebook, Github, some banks, and much more… . . Normally, the protocol requires your security key to be enrolled on each site before being able to authenticate with it. Since Authelia provides Single Sign-On, your users will need to enroll their device only once to get access to all your applications. . . After having successfully passed the first factor, select Security Key method and click on Not registered yet? link. This will send you an email to verify your identity. . NOTE: This e-mail has likely been sent to the mailbox at https://mail.example.com:8080/ if you’re testing Authelia. . Confirm your identity by clicking on Register and you’ll be asked to touch the token of your security key to complete the enrollment. . Upon successful enrollment, you can authenticate using your security key by simply touching the token again when requested: . . Easy, right?! . FAQ . Why don’t I have access to the Security Key option? . U2F protocol is a new protocol that is only supported by recent browsers and might even be enabled on some of them. Please be sure your browser supports U2F and that the feature is enabled to make the option available in Authelia. .",
    "url": "https://docs.authelia.com/features/2fa/security-key.html",
    "relUrl": "/features/2fa/security-key.html"
  }
  ,"43": {
    "title": "Server",
    "content": "Server . The server section configures and tunes the http server module Authelia uses. . Configuration . # Configuration options specific to the internal http server server: # Buffers usually should be configured to be the same value. # Explanation at https://docs.authelia.com/configuration/server.html # Read buffer size configures the http server&#39;s maximum incoming request size in bytes. read_buffer_size: 4096 # Write buffer size configures the http server&#39;s maximum outgoing response size in bytes. write_buffer_size: 4096 . Buffer Sizes . The read and write buffer sizes generally should be the same. This is because when Authelia verifies if the user is authorized to visit a URL, it also sends back nearly the same size response (write_buffer_size) as the request (read_buffer_size). .",
    "url": "https://docs.authelia.com/configuration/server.html",
    "relUrl": "/configuration/server.html"
  }
  ,"44": {
    "title": "Session",
    "content": "Session . Authelia relies on session cookies to authenticate users. When the user visits a website of the protected domain example.com for the first time, Authelia detects that there is no cookie for that user. Consequently, Authelia redirects the user to the login portal through which the user should authenticate to get a cookie which is valid for *.example.com, meaning all websites of the domain. At the next request, Authelia receives the cookie associated to the authenticated user and can then order the reverse proxy to let the request pass through to the application. . Configuration . session: # The name of the session cookie. (default: authelia_session). name: authelia_session # The secret to encrypt the session cookie. # Secret can also be set using a secret: https://docs.authelia.com/configuration/secrets.html secret: unsecure_session_secret # The time in seconds before the cookie expires and session is reset. expiration: 1h # The inactivity time in seconds before the session is reset. inactivity: 5m # The remember me duration. # Value of 0 disables remember me. # Value is in seconds, or duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format # Longer periods are considered less secure because a stolen cookie will last longer giving attackers more time to spy # or attack. Currently the default is 1M or 1 month. remember_me_duration: 1M # The domain to protect. # Note: the login portal must also be a subdomain of that domain. domain: example.com # The redis connection details (optional) # If not provided, sessions will be stored in memory redis: host: 127.0.0.1 port: 6379 # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: authelia . Security . Configuration of this section has an impact on security. You should read notes in security measures for more information. . Duration Notation . The configuration parameters expiration, inactivity, and remember_me_duration use duration notation. See the documentation for duration notation format for more information. .",
    "url": "https://docs.authelia.com/configuration/session.html",
    "relUrl": "/configuration/session.html"
  }
  ,"45": {
    "title": "Single Factor",
    "content": "Single Factor . Authelia supports single factor authentication to let applications send authenticated requests to other applications. . Single or two-factor authentication can be configured per resource of an application for flexibility. . For instance, you can configure Authelia to grant access to all resources matching app1.example.com/api/(.*) with only a single factor and all resources matching app1.example.com/admin with two factors. . To know more about the configuration of the feature, please visit the documentation about the configuration. . Proxy-Authorization header . Authelia reads credentials from the header Proxy-Authorization instead of the usual Authorization header. This is because in some circumstances both Authelia and the application could require authentication in order to provide specific authorizations at the level of the application. .",
    "url": "https://docs.authelia.com/features/single-factor.html",
    "relUrl": "/features/single-factor.html"
  }
  ,"46": {
    "title": "SMTP",
    "content": "SMTP . Authelia can send emails to users through an SMTP server. It can be configured as described below. . # Configuration of the notification system. # # Notifications are sent to users when they require a password reset, a u2f # registration or a TOTP registration. # Use only an available configuration: filesystem, smtp. notifier: # You can disable the notifier startup check by setting this to true. disable_startup_check: false # For testing purpose, notifications can be sent in a file. ## filesystem: ## filename: /tmp/authelia/notification.txt # Use a SMTP server for sending notifications. Authelia uses PLAIN or LOGIN method to authenticate. # [Security] By default Authelia will: # - force all SMTP connections over TLS including unauthenticated connections # - use the disable_require_tls boolean value to disable this requirement (only works for unauthenticated connections) # - validate the SMTP server x509 certificate during the TLS handshake against the hosts trusted certificates # - trusted_cert option: # - this is a string value, that may specify the path of a PEM format cert, it is completely optional # - if it is not set, a blank string, or an invalid path; will still trust the host machine/containers cert store # - defaults to the host machine (or docker container&#39;s) trusted certificate chain for validation # - use the trusted_cert string value to specify the path of a PEM format public cert to trust in addition to the hosts trusted certificates # - use the disable_verify_cert boolean value to disable the validation (prefer the trusted_cert option as it&#39;s more secure) smtp: username: test # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: password host: 127.0.0.1 port: 1025 sender: admin@example.com # Subject configuration of the emails sent. # {title} is replaced by the text from the notifier subject: &quot;[Authelia] {title}&quot; # This address is used during the startup check to verify the email configuration is correct. It&#39;s not important what it is except if your email server only allows local delivery. ## startup_check_address: test@authelia.com ## trusted_cert: &quot;&quot; ## disable_require_tls: false ## disable_verify_cert: false . Using Gmail . You need to generate an app password in order to use Gmail SMTP servers. The process is described here . notifier: smtp: username: myaccount@gmail.com # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: yourapppassword sender: admin@example.com host: smtp.gmail.com port: 587 . Loading a password from a secret instead of inside the configuration . Password can also be defined using a secret. .",
    "url": "https://docs.authelia.com/configuration/notifier/smtp.html",
    "relUrl": "/configuration/notifier/smtp.html"
  }
  ,"47": {
    "title": "SQLite",
    "content": "SQLite . If you don’t have a SQL server, you can use SQLite. However please note that this setup will prevent you from running multiple instances of Authelia since the database will be a local file. . Configuration . Just give the path to the sqlite database. It will be created if the file does not exist. . storage: local: path: /var/lib/authelia/db.sqlite3 .",
    "url": "https://docs.authelia.com/configuration/storage/sqlite.html",
    "relUrl": "/configuration/storage/sqlite.html"
  }
  ,"48": {
    "title": "Suites",
    "content": "Suites . Authelia is a single component in interaction with many others in a complete ecosystem. Consequently, testing the features is not as easy as we might think. In order to solve this problem, Authelia came up with the concept of suite which is a kind of virtual environment for Authelia and a set of tests. A suite can setup components such as nginx, redis or mariadb in which Authelia can run and be tested. . This abstraction allows to prepare an environment for manual testing during development and also to craft and run integration tests efficiently. . Start a suite. . Starting a suite called Standalone is done with the following command: . $ authelia-scripts suites setup Standalone . This command deploys the environment of the suite. . Run tests of a suite . Run tests of running suite . If a suite is already running, you can simply type the test command that will run the test related to the currently running suite: . $ authelia-scripts suites test . Run tests of non-running suite . However, if no suite is running yet and you just want to run the tests of a specific suite like HighAvailability, you can do so with the next command: . # Set up the env, run the tests and tear down the env $ authelia-scripts suites test HighAvailability . Run all tests of all suites . Running all tests is easy. Make sure that no suite is already running and run: . $ authelia-scripts suites test . Run tests in headless mode . As you might have noticed, the tests are run using chromedriver and selenium. It means that the tests open an instance of Chrome that might interfere with your other activities. In order to run the tests in headless mode to avoid the interference, use the following command: . $ authelia-scripts suites test --headless . Create a suite . Creating a suite is as easy. Let’s take the example of the Standalone suite: . suite_standalone.go - It defines the setup and teardown phases. It likely uses docker-compose to setup the ecosystem. This file also defines the timeouts. | suite_standalone_test.go - It defines the set of tests to run against the suite. | Standalone directory - It contains resources required by the suite and likely mounted in the containers. | . A suite can also be much more complex like setting up a complete Kubernetes ecosystem. You can check the Kubernetes suite as example. .",
    "url": "https://docs.authelia.com/contributing/suites.html",
    "relUrl": "/contributing/suites.html"
  }
  ,"49": {
    "title": "Threat Model",
    "content": "Threat Model . The design goals for Authelia is to protect access to applications by collaborating with reverse proxies to prevent attacks coming from the edge of the network. This document gives an overview of what Authelia is protecting against but some of those points are also detailed in Security Measures. . General assumptions . Authelia is considered to be running within a trusted network and it heavily relies on the first level of security provided by reverse proxies. It’s very important that you take time configuring your reverse proxy properly to get all the authentication benefits brought by Authelia. Some general security tweaks are listed in Security Measures to give you some ideas. . Guarantees . If properly configured, Authelia guarantees the following for security of your users and your apps: . Applications cannot be accessed without proper authorization. The access control list is highly configurable allowing administrators to guarantee least privilege principle. | Applications can be protected with two factors in order to fight against credentials theft and protect highly sensitive data or operations. | Sessions are bound in time, limiting the impact of a cookie theft. Sessions can have both soft and hard limits. With soft limit, the user is logged out when inactive for a certain period. With hard limit, the user has to authenticate again after a certain period, whether they were active or not. | Brute force attacks against credentials are protected thanks to a regulation mechanism temporarily blocking the user account after too many attempts. | Identity validation is required for performing administrative actions such as registering 2FA devices, preventing attackers to pass second factor by auto-registering their own 2FA device. An email with a link is sent to the user and a click is required to confirm the action. | Prevention against session fixation by regenerating a new session after each privilege elevation. | Prevention against LDAP injection by following OWASP recommendations regarding valid input characters (https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html). | Connections between Authelia and thirdparty components like mail server, database, cache and LDAP server can be made over TLS to protect against man-in-the-middle attacks from within the infrastructure. | . Potential future guarantees . Define and enforce a password policy (to be designed since such a policy can clash with a policy set by the LDAP server). | Detect credential theft and prevent malicious actions. | Detect session cookie theft and prevent malicious actions. | Authenticate communications between Authelia and reverse proxy. | Securely transmit authentication data to backends (OAuth2 with bearer tokens). | Protect secrets stored in DB with encryption to prevent secrets leak by DB exfiltration. | Least privilege on LDAP binding operations (currently administrative user is used to bind while it could be anonymous). | . Trusted environment . It’s important to note that Authelia is considered running in a trusted environment for two reasons . Requests coming to Authelia should be initiated by reverse proxies but CAN be initiated by any other server currently. There is no trusted relationship between Authelia and the reverse proxy so an attacker within the network could abuse Authelia and attack it. | Your environment should be considered trusted especially if you’re using the Remote-User and Remote-Groups headers to forward authentication data to your backends. These headers are transmitted plain and unsigned to the backends, meaning a malicious user within the network could pretend to be Authelia and send those headers to bypass authentication and gain access to the service. A mitigation could be to transmit those headers with a digital signature which could be verified by the backend however, many backends just don’t support it. It has therefore been decided to invest on OpenID Connect instead to solve that authentication delegation problem. Indeed, many backends do support OAuth2 though since it has become a standard lately. |",
    "url": "https://docs.authelia.com/security/threat-model.html",
    "relUrl": "/security/threat-model.html"
  }
  ,"50": {
    "title": "Traefik 1.x",
    "content": "Traefik . Traefik 1.x is a reverse proxy supported by Authelia. . Configuration . Below you will find commented examples of the following configuration: . Traefik 1.x | Authelia portal | Protected endpoint (Nextcloud) | . The below configuration looks to provide examples of running Traefik 1.x with labels to protect your endpoint (Nextcloud in this case). . Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. . docker-compose.yml . version: &#39;3&#39; networks: net: driver: bridge services: traefik: image: traefik:v1.7.20-alpine container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - &#39;traefik.frontend.rule=Host:traefik.example.com&#39; - &#39;traefik.port=8081&#39; ports: - 80:80 - 443:443 - 8081:8081 restart: unless-stopped command: - &#39;--api&#39; - &#39;--api.entrypoint=api&#39; - &#39;--docker&#39; - &#39;--defaultentrypoints=https&#39; - &#39;--logLevel=DEBUG&#39; - &#39;--traefiklog=true&#39; - &#39;--traefiklog.filepath=/var/log/traefik.log&#39; - &#39;--entryPoints=Name:http Address::80&#39; - &#39;--entryPoints=Name:https Address::443 TLS&#39; - &#39;--entryPoints=Name:api Address::8081&#39; authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/var/lib/authelia - /path/to/authelia/config.yml:/etc/authelia/configuration.yml:ro networks: - net labels: - &#39;traefik.frontend.rule=Host:login.example.com&#39; expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - &#39;traefik.frontend.rule=Host:nextcloud.example.com&#39; - &#39;traefik.frontend.auth.forward.address=http://authelia:9091/api/verify?rd=https://login.example.com/&#39; - &#39;traefik.frontend.auth.forward.trustForwardHeader=true&#39; - &#39;traefik.frontend.auth.forward.authResponseHeaders=Remote-User,Remote-Groups&#39; expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne .",
    "url": "https://docs.authelia.com/deployment/supported-proxies/traefik1.x.html",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html"
  }
  ,"51": {
    "title": "Traefik 2.x",
    "content": "Traefik2 . Traefik 2.x is a reverse proxy supported by Authelia. . Configuration . Below you will find commented examples of the following configuration: . Traefik 2.x | Authelia portal | Protected endpoint (Nextcloud) | . The below configuration looks to provide examples of running Traefik 2.x with labels to protect your endpoint (Nextcloud in this case). . Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. . docker-compose.yml . version: &#39;3&#39; networks: net: driver: bridge services: traefik: image: traefik:v2.1.2 container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - &#39;traefik.enable=true&#39; - &#39;traefik.http.routers.api.rule=Host(`traefik.example.com`)&#39; - &#39;traefik.http.routers.api.entrypoints=https&#39; - &#39;traefik.http.routers.api.service=api@internal&#39; - &#39;traefik.http.routers.api.tls=true&#39; ports: - 80:80 - 443:443 command: - &#39;--api&#39; - &#39;--providers.docker=true&#39; - &#39;--providers.docker.exposedByDefault=false&#39; - &#39;--entrypoints.http=true&#39; - &#39;--entrypoints.http.address=:80&#39; - &#39;--entrypoints.https=true&#39; - &#39;--entrypoints.https.address=:443&#39; - &#39;--log=true&#39; - &#39;--log.level=DEBUG&#39; - &#39;--log.filepath=/var/log/traefik.log&#39; authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/var/lib/authelia - /path/to/authelia/config.yml:/etc/authelia/configuration.yml:ro networks: - net labels: - &#39;traefik.enable=true&#39; - &#39;traefik.http.routers.authelia.rule=Host(`login.example.com`)&#39; - &#39;traefik.http.routers.authelia.entrypoints=https&#39; - &#39;traefik.http.routers.authelia.tls=true&#39; - &#39;traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.example.com/&#39; - &#39;traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true&#39; - &#39;traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups&#39; expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - &#39;traefik.enable=true&#39; - &#39;traefik.http.routers.nextcloud.rule=Host(`nextcloud.example.com`)&#39; - &#39;traefik.http.routers.nextcloud.entrypoints=https&#39; - &#39;traefik.http.routers.nextcloud.tls=true&#39; - &#39;traefik.http.routers.nextcloud.middlewares=authelia@docker&#39; expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne .",
    "url": "https://docs.authelia.com/deployment/supported-proxies/traefik2.x.html",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html"
  }
  ,"52": {
    "title": "2FA through basic auth",
    "content": "The following project allows you to use Authelia’s one-time password (OTP) 2-factor authentication (2FA) through only basic auth and a custom credentials format described below. This allows you to use 2FA on clients and scenarios that demand basic auth, e.g. webdav network streaming. More information: . authelia-basic-2fa .",
    "url": "https://docs.authelia.com/community/two-factor-basic-auth.html",
    "relUrl": "/community/two-factor-basic-auth.html"
  }
  ,"53": {
    "title": "Using Remote-User header for SSO with Jira",
    "content": "Using Remote-User header for SSO with Jira . You can make Jira auto-login to the user that is currently logged in to authelia. I say “auto-login” as I couldn’t find any plugin to actually be authentication provider through HTTP headers only - LDAP though seems to have support. . So this guide is targeted to authelia users that don’t use any other authentication backend. . I’m using traefik with docker as an example, but any proxy that can forward authelia Remote-User header is fine. . First of all, users should exist on both authelia and Jira AND have the same username for this to work. Also you will have to pay for a plugin. . After both steps are done: . Add traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User in the labels of authelia | Add traefik.http.routers.jira.middlewares=authelia@docker in the labels of Jira (to actually enable authelia for the jira instance) | Install EasySSO in Jira | Go to EasySSO preferences and add the “Remote-User” header under HTTP and tick the “Username” checkbox. | Save | . Other Systems . While this guide is tailored for Jira, you can use a similar method with many other services like Jenkins and Grafana. .",
    "url": "https://docs.authelia.com/community/using-remote-user-header-for-sso-with-jira.html",
    "relUrl": "/community/using-remote-user-header-for-sso-with-jira.html"
  }
  
}