{"0": {
    "doc": "Access Control",
    "title": "Access Control",
    "content": "Authelia allows to define a fine-grained rule-based access control policy in configuration. This list of rules is tested against any requests protected by Authelia and defines the level of authentication the user must pass to get access to the resource. For instance a rule can look like this: . - domain: dev.example.com resources: - \"^/groups/dev/.*$\" subject: \"group:dev\" policy: two_factor . This rule matches when the request targets the domain dev.example.com and the path matches the regular expression ^/groups/dev/.*$. In that case, a two-factor policy is applied requiring the user to authenticate with two factors. ",
    "url": "/docs/features/access-control.html",
    "relUrl": "/features/access-control.html"
  },"1": {
    "doc": "Access Control",
    "title": "Configuration",
    "content": "Please check the dedicated documentation . ",
    "url": "/docs/features/access-control.html#configuration",
    "relUrl": "/features/access-control.html#configuration"
  },"2": {
    "doc": "Access Control",
    "title": "Access Control",
    "content": " ",
    "url": "/docs/configuration/access-control.html",
    "relUrl": "/configuration/access-control.html"
  },"3": {
    "doc": "Access Control",
    "title": "Policies",
    "content": "With Authelia you can define a list of rules that are going to be evaluated in sequential order when authorization is delegated to Authelia. The first matching rule of the list defines the policy applied to the resource, if no rule matches the resource a customizable default policy is applied. deny . This is the policy applied by default, and is what we recommend as the default policy for all installs. Its effect is literally to deny the user access to the resource. Additionally you can use this policy to conditionally deny access in desired situations. Examples include denying access to an API that has no authentication mechanism built in. bypass . This policy skips all authentication and allows anyone to use the resource. This policy is not available with a rule that includes a subject restriction because the minimum authentication level required to obtain information about the subject is one_factor. one_factor . This policy requires the user at minimum complete 1FA successfully (username and password). This means if they have performed 2FA then they will be allowed to access the resource. two_factor . This policy requires the user to complete 2FA successfully. This is currently the highest level of authentication policy available. ",
    "url": "/docs/configuration/access-control.html#policies",
    "relUrl": "/configuration/access-control.html#policies"
  },"4": {
    "doc": "Access Control",
    "title": "Default Policy",
    "content": "The default policy is the policy applied when no other rule matches. It is recommended that this is configured to deny for security reasons. Sites which you do not wish to secure with Authelia should not be configured to perform authentication with Authelia at all. See Policies for more information. ",
    "url": "/docs/configuration/access-control.html#default-policy",
    "relUrl": "/configuration/access-control.html#default-policy"
  },"5": {
    "doc": "Access Control",
    "title": "Network Aliases",
    "content": "The main networks section defines a list of network aliases, where the name matches a list of networks. These names can be used in any rule instead of a literal network. This makes it easier to define a group of networks multiple times. You can combine both literal networks and these aliases inside the networks section of a rule. See this section for more details. ",
    "url": "/docs/configuration/access-control.html#network-aliases",
    "relUrl": "/configuration/access-control.html#network-aliases"
  },"6": {
    "doc": "Access Control",
    "title": "Rules",
    "content": "A rule defines two things: . | the matching criteria of the request presented to the reverse proxy | the policy applied when all criteria match. | . The criteria are: . | domain: domain or list of domains targeted by the request. | resources: pattern or list of patterns that the path should match. | subject: the user or group of users to define the policy for. | networks: the network addresses, ranges (CIDR notation) or groups from where the request originates. | methods: the http methods used in the request. | . A rule is matched when all criteria of the rule match. Rules are evaluated in sequential order, and this is particularly important for bypass rules. Bypass rules should generally appear near the top of the rules list. Policy . A policy represents the level of authentication the user needs to pass before being authorized to request the resource. See Policies for more information. Domains . The domains defined in rules must obviously be either a subdomain of the domain protected by Authelia or the protected domain itself. In order to match multiple subdomains, the wildcard matcher character *. can be used as prefix of the domain. For instance, to define a rule for all subdomains of example.com, one would use *.example.com in the rule. A single rule can define multiple domains for matching. These domains can be either listed in YAML-short form [\"example1.com\", \"example2.com\"] or in YAML long-form as dashed list. Domain prefixes can also be dynamically match users or groups. For example you can have a specific policy adjustment if the user or group matches the subdomain. For example {user}.example.com or {group}.example.com check the users name or groups against the subdomain. Resources . A rule can define multiple regular expressions for matching the path of the resource similar to the list of domains. If any one of them matches, the resource criteria of the rule matches. Note that regular expressions can be used to match a given path. However prior to 4.27.0, they do not match the query parameters in the URL, only the path. If you’re upgrading to 4.27.0+ you may have to alter some resource rules to get them to work as they previously did. You might also face some escaping issues preventing Authelia to start. Please make sure that when you are using regular expressions, you enclose them between quotes. It’s optional but it will likely save you a lot of debugging time. Subjects . A subject is a representation of a user or a group of user for who the rule should apply. For a user with unique identifier john, the subject should be user:john and for a group uniquely identified by developers, the subject should be group:developers. Similar to resources and domains you can define multiple subjects in a single rule. If you want a combination of subjects to be matched at once using a logical AND, you can specify a nested list of subjects like - [\"group:developers\", \"group:admins\"]. In summary, the first list level of subjects are evaluated using a logical OR, whereas the second level by a logical AND. The last example below reads as: the group is dev AND the username is john OR the group is admins. Combining subjects and the bypass policy . A subject cannot be combined with the bypass policy since the minimum authentication level to identify a subject is one_factor. Combining the one_factor policy with a subject is effectively the same as setting the policy to bypass in the past. We have taken an opinionated stance on preventing this configuration as it could result in problematic security scenarios with badly thought out configurations and cannot see a likely configuration scenario that would require users to do this. If you have a scenario in mind please open an issue on GitHub. Networks . A list of network addresses, ranges (CIDR notation) or groups can be specified in a rule in order to apply different policies when requests originate from different networks. This list can contain both literal definitions of networks and network aliases. Network addresses specified will be matched against the first IP in the X-Forwarded-For, and if there is none it will fall back to the IP address of the request. If using Authelia with a reverse proxy, additional configuration may be required on the reverse proxy to ensure these headers are present and correct. Main use cases for this rule option is to adjust the security requirements of a resource based on the location of the user. For example lets say a resource should be exposed both on the Internet and from an authenticated VPN for instance. Passing a second factor a first time to get access to the VPN and a second time to get access to the application can sometimes be cumbersome if the endpoint is not considered overly sensitive. An additional situation where this may be useful is if there is a specific network you wish to deny access or require a higher level of authentication for; like a public machine network vs a company device network, or a BYOD network. Even if Authelia provides this flexibility, you might prefer a higher level of security and avoid this option entirely. You and only you can define your security policy and it’s up to you to configure Authelia accordingly. Methods . A list of HTTP request methods to apply the rule to. Valid values are GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, and TRACE. Additional information about HTTP request methods can be found on the MDN. It’s important to note this policy type is primarily intended for use when you wish to bypass authentication for a specific request method. This is because there are several key limitations in what is possible to accomplish without Authelia being a reverse proxy server. This rule type is discouraged unless you really know what you’re doing or you wish to setup a rule to bypass CORS preflight requests by bypassing for the OPTIONS method. For example, if you require authentication only for write events (POST, PATCH, DELETE, PUT), when a user who is not currently authenticated tries to do one of these actions, they will be redirected to Authelia. Authelia will decide what level is required for authentication, and then after the user authenticates it will redirect them to the original URL where Authelia decided they needed to authenticate. So if the endpoint they are redirected to originally had data sent as part of the request, this data is completely lost. Further if the endpoint expects the data or doesn’t allow GET request types, the user may be presented with an error leading to a bad user experience. ",
    "url": "/docs/configuration/access-control.html#rules",
    "relUrl": "/configuration/access-control.html#rules"
  },"7": {
    "doc": "Access Control",
    "title": "Complete example",
    "content": "Here is a complete example of complex access control list that can be defined in Authelia. access_control: default_policy: deny networks: - name: internal networks: - 10.10.0.0/16 - 192.168.2.0/24 - name: VPN networks: 10.9.0.0/16 rules: - domain: public.example.com policy: bypass - domain: \"*.example.com\" policy: bypass methods: - OPTIONS - domain: secure.example.com policy: one_factor networks: - internal - VPN - 192.168.1.0/24 - 10.0.0.1 - domain: - secure.example.com - private.example.com policy: two_factor - domain: singlefactor.example.com policy: one_factor - domain: \"mx2.mail.example.com\" subject: \"group:admins\" policy: deny - domain: \"*.example.com\" subject: - \"group:admins\" - \"group:moderators\" policy: two_factor - domain: dev.example.com resources: - \"^/groups/dev/.*$\" subject: \"group:dev\" policy: two_factor - domain: dev.example.com resources: - \"^/users/john/.*$\" subject: - [\"group:dev\", \"user:john\"] - \"group:admins\" policy: two_factor - domain: \"{user}.example.com\" policy: bypass . ",
    "url": "/docs/configuration/access-control.html#complete-example",
    "relUrl": "/configuration/access-control.html#complete-example"
  },"8": {
    "doc": "Miscellaneous Additional Resources",
    "title": "Articles",
    "content": "Setting Up Authelia With SWAG Authelia Tutorial – Protect your Docker Traefik stack with Private MFA . ",
    "url": "/docs/community/additional-resources.html#articles",
    "relUrl": "/community/additional-resources.html#articles"
  },"9": {
    "doc": "Miscellaneous Additional Resources",
    "title": "Youtube Videos",
    "content": "Authelia: Install Guide on Unraid + NGINX (Deep Dive) . ",
    "url": "/docs/community/additional-resources.html#youtube-videos",
    "relUrl": "/community/additional-resources.html#youtube-videos"
  },"10": {
    "doc": "Miscellaneous Additional Resources",
    "title": "Miscellaneous Additional Resources",
    "content": "In this document you will find miscellaneous resources that could give you more information on Authelia or help you set it up. ",
    "url": "/docs/community/additional-resources.html",
    "relUrl": "/community/additional-resources.html"
  },"11": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": "Authelia is a companion of reverse proxies like Nginx, Traefik and HAProxy. It can be seen as an extension of those proxies providing authentication functions and a login portal. As shown in the following architecture diagram, Authelia is directly connected to the reverse proxy but never directly connected to application backends. ",
    "url": "/docs/home/architecture.html",
    "relUrl": "/home/architecture.html"
  },"12": {
    "doc": "Architecture",
    "title": "Workflow",
    "content": "Reverse proxies are configured so that every incoming request generates an authentication request sent to Authelia. Authelia responds and will instruct the reverse proxy to either allow the incoming request to pass through, or block it because the user is not authenticated or is not sufficiently authorized. Step by step . When the first request of an unauthenticated user hits the reverse proxy, Authelia determines the user is not authenticated because no session cookie has been sent along with the request. Consequently, Authelia redirects the user to the authentication portal provided by Authelia itself. The user can then execute the authentication workflow using that portal to obtain a session cookie valid for all subdomains of the domain protected by Authelia. When the user visits the initial website again, the query is sent along with the session cookie which is forwarded in the authentication request to Authelia. This time, Authelia can verify the user is authenticated and order the reverse proxy to let the query pass through. Sequence Diagram . Here is a description of the complete workflow: . ",
    "url": "/docs/home/architecture.html#workflow",
    "relUrl": "/home/architecture.html#workflow"
  },"13": {
    "doc": "Architecture",
    "title": "HTTP/HTTPS",
    "content": "Authelia only works for websites served over HTTPS because the session cookie can only be transmitted over secure connections. Please note that it has been decided that we won’t support websites served over HTTP in order to avoid any risk due to misconfiguration. (see #590). If a self-signed certificate is required, the following command can be used to generate one: . # Generate a certificate covering \"example.com\" for one year in the /tmp/certs/ directory. $ docker run authelia/authelia authelia certificates generate --host example.com --dir /tmp/certs/ . ",
    "url": "/docs/home/architecture.html#httphttps",
    "relUrl": "/home/architecture.html#httphttps"
  },"14": {
    "doc": "Authelia Scripts",
    "title": "Authelia Scripts",
    "content": "Authelia comes with a set of dedicated scripts doing a broad range of operations such as building the distributed version of Authelia, building the Docker image, running suites, testing the code, etc… . Those scripts becomes available after sourcing the bootstrap.sh script with . $ source bootstrap.sh . Then, you can access the scripts usage by running the following command: . $ authelia-scripts --help . For instance, you can build Authelia (Go binary and frontend) with: . $ authelia-scripts build . Or build the official Docker image with: . $ authelia-scripts docker build . Or start the Standalone suite with: . $ authelia-scripts suites setup Standalone . You will find more information in the scripts usage helpers. ",
    "url": "/docs/contributing/authelia-scripts.html",
    "relUrl": "/contributing/authelia-scripts.html"
  },"15": {
    "doc": "Build & Dev",
    "title": "Build &amp; Dev",
    "content": "Authelia is written in Go and comes with a dedicated CLI called authelia-scripts which is available after running source bootstrap.sh. This CLI provides many useful tools to help you during development. In order to build and contribute to Authelia, you need to make sure Go &gt;= v1.13, Docker, docker-compose and Node &gt;= v12 are installed on your machine. ",
    "url": "/docs/contributing/build-and-dev.html#build--dev",
    "relUrl": "/contributing/build-and-dev.html#build--dev"
  },"16": {
    "doc": "Build & Dev",
    "title": "Get started",
    "content": "Authelia is made of Go application serving the API and a React application for the portal. In order to ease development, Authelia uses the concept of suites to run Authelia from source code so that your patches are included. This is a kind of virtual environment running Authelia in a complete ecosystem (LDAP, Redis, SQL server). Note that Authelia is hot-reloaded in the environment so that your patches are instantly included. The next command starts the suite called Standalone: . $ authelia-scripts suites setup Standalone . Most of the suites are using docker-compose to bootstrap the environment. Therefore, you can check the logs of all application by running the following command on the component you want to monitor. $ docker logs authelia_authelia-backend_1 -f . Then, edit the code and observe how Authelia is automatically reloaded. Unit tests . To run the unit tests, run: . $ authelia-scripts unittest . Integration tests . Integration tests are located under the internal/suites directory and are based on Selenium. A suite is a combination of environment and tests. Executing a suite therefore means starting the environment, running the tests and tearing down the environment. Each step can be run independently: . # List the available suites $ authelia-scripts suites list Standalone DuoPush LDAP Traefik # Start the environment of Standalone suite. $ authelia-scripts suites setup Standalone # Run the tests related to the currently running suite. $ authelia-scripts suites test # Tear down the environment $ authelia-scripts suites teardown Standalone . In order to test all suites (approx 30 minutes), you need to make sure there is no currently running suite and then you should run: . $ authelia-scripts suites test . Also, you don’t need to start the suite before testing it. Given you’re not running any suite, just use the following command to test the Standalone suite. $ authelia-scripts suites test Standalone . The suite will be spawned, tests will be run and then the suite will be torn down automatically. ",
    "url": "/docs/contributing/build-and-dev.html#get-started",
    "relUrl": "/contributing/build-and-dev.html#get-started"
  },"17": {
    "doc": "Build & Dev",
    "title": "Build & Dev",
    "content": " ",
    "url": "/docs/contributing/build-and-dev.html",
    "relUrl": "/contributing/build-and-dev.html"
  },"18": {
    "doc": "Commit Message Guidelines",
    "title": "Commit Message Guidelines",
    "content": " ",
    "url": "/docs/contributing/commitmsg-guidelines.html",
    "relUrl": "/contributing/commitmsg-guidelines.html"
  },"19": {
    "doc": "Commit Message Guidelines",
    "title": "The reasons for these conventions:",
    "content": ". | simple navigation though and easier to read git history | . ",
    "url": "/docs/contributing/commitmsg-guidelines.html#the-reasons-for-these-conventions",
    "relUrl": "/contributing/commitmsg-guidelines.html#the-reasons-for-these-conventions"
  },"20": {
    "doc": "Commit Message Guidelines",
    "title": "Format of the commit message:",
    "content": "Each commit message consists of a header, a body, and a footer. &lt;header&gt; &lt;BLANK LINE&gt; &lt;body&gt; &lt;BLANK LINE&gt; &lt;footer&gt; . The header is mandatory and must conform to the Commit Message Header format. The body is mandatory for all commits except for those of type “docs”. When the body is present it must be at least 20 characters long and must conform to the Commit Message Body format. The footer is optional. The Commit Message Footer format describes what the footer is used for, and the structure it must have. Any line of the commit message cannot be longer than 100 characters. Commit Message Header . &lt;type&gt;(&lt;scope&gt;): &lt;summary&gt; │ │ │ │ │ └─⫸ Summary in present tense. Not capitalized. No period at the end. │ │ │ └─⫸ Commit Scope: api|authentication|authorization|cmd|commands|configuration|duo| │ handlers|logging|middlewares|mocks|models|notification|regulation| │ server|session|storage|suites|templates|utils|web │ └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|release|test . The &lt;type&gt; and &lt;summary&gt; fields are mandatory, the (&lt;scope&gt;) field is optional. Allowed &lt;type&gt; values: . | build Changes that affect the build system or external dependencies (example scopes: bundler, deps, docker, go, npm) | ci Changes to our CI configuration files and scripts (example scopes: autheliabot, buildkite, codecov, golangci-lint, renovate, reviewdog) | docs Documentation only changes | feat A new feature | fix A bug fix | perf A code change that improves performance | refactor A code change that neither fixes a bug nor adds a feature | release Releasing a new version of Authelia | test Adding missing tests or correcting existing tests | . Allowed &lt;scope&gt; values: . The scope should be the name of the package affected (as perceived by the person reading the changelog generated from commit messages). | authentication | authorization | commands | configuration | duo | handlers | logging | middlewares | mocks | models | notification | regulation | server | session | storage | suites | templates | utils | . There are currently a few exceptions to the “use package name” rule: . | api: used for changes that change the openapi specification . | cmd: used for changes to the authelia|authelia-scripts|authelia-suites top level binaries . | web: used for changes to the React based frontend . | none/empty string: useful for test, refactor and changes that are done across multiple packages (e.g. test: add missing unit tests) and for docs changes that are not related to a specific package (e.g. docs: fix typo in tutorial). | . Summary . Use the summary field to provide a succinct description of the change: . | use the imperative, present tense: “change” not “changed” nor “changes” | don’t capitalize the first letter | no dot (.) at the end | . Commit Message Body . Just as in the summary, use the imperative, present tense: “fix” not “fixed” nor “fixes”. Explain the motivation for the change in the commit message body. This commit message should explain why you are making the change. You can include a comparison of the previous behavior with the new behavior in order to illustrate the impact of the change. Commit Message Footer . The footer can contain information about breaking changes and is also the place to reference GitHub issues and other PRs that this commit closes or is related to. BREAKING CHANGE: &lt;breaking change summary&gt; &lt;BLANK LINE&gt; &lt;breaking change description + migration instructions&gt; &lt;BLANK LINE&gt; &lt;BLANK LINE&gt; Fixes #&lt;issue number&gt; . Breaking Change section should start with the phrase “BREAKING CHANGE: “ followed by a summary of the breaking change, a blank line, and a detailed description of the breaking change that also includes migration instructions. Revert commits . If the commit reverts a previous commit, it should begin with revert: , followed by the header of the reverted commit. The content of the commit message body should contain: . | information about the SHA of the commit being reverted in the following format: This reverts commit &lt;SHA&gt;, | a clear description of the reason for reverting the commit message. | . ",
    "url": "/docs/contributing/commitmsg-guidelines.html#format-of-the-commit-message",
    "relUrl": "/contributing/commitmsg-guidelines.html#format-of-the-commit-message"
  },"21": {
    "doc": "Commit Message Guidelines",
    "title": "Example commit message:",
    "content": "fix(logging): disabled colored logging outputs when file is specified In some scenarios if a user has a log_file_path specified and a TTY seems to be detected this causes terminal coloring outputs to be written to the file. This in turn will cause issues when attempting to utilise the log with the provided fail2ban regexes. We now override any TTY detection/logging treatments and disable coloring/removal of the timestamp when a user is utilising the text based logger to a file. Fixes #1480. This document is based on AngularJS Git Commit Message Format. ",
    "url": "/docs/contributing/commitmsg-guidelines.html#example-commit-message",
    "relUrl": "/contributing/commitmsg-guidelines.html#example-commit-message"
  },"22": {
    "doc": "Deployment - Highly-Available",
    "title": "Highly-Available Deployment",
    "content": "Authelia can be deployed on bare metal or on Kubernetes with two different kind of artifacts: the distributable version (binary and public_html) or a Docker image. NOTE: If not done already, we highly recommend you first follow the Getting Started documentation. ",
    "url": "/docs/deployment/deployment-ha.html#highly-available-deployment",
    "relUrl": "/deployment/deployment-ha.html#highly-available-deployment"
  },"23": {
    "doc": "Deployment - Highly-Available",
    "title": "On Bare Metal",
    "content": "Authelia has been designed to be a proxy companion handling the authentication and authorization requests for your entire infrastructure. As Authelia will be key to your architecture, it requires several components to make it highly-available. Deploying it in production means having an LDAP server for storing the information about the users, a Redis cache to store the user sessions in a distributed manner, a SQL server like MariaDB to persist user configurations and one or more nginx reverse proxies configured to be used with Authelia. With such a setup Authelia can easily be scaled to multiple instances to evenly handle the traffic. Here are the available steps to deploy Authelia given the configuration file is /path/to/your/configuration.yml. Note that you can create your own configuration file from config.template.yml located at the root of the repo. NOTE: Prefer using environment variables to set secrets in production otherwise pay attention to the permissions of the configuration file. See secrets for more information. Deploy with the distributable version . # Build it if not done already $ authelia-scripts build $ authelia --config /path/to/your/configuration.yml . Deploy With Docker . $ docker run -v /path/to/your/configuration.yml:/config/configuration.yml -e TZ=Europe/Paris authelia/authelia . ",
    "url": "/docs/deployment/deployment-ha.html#on-bare-metal",
    "relUrl": "/deployment/deployment-ha.html#on-bare-metal"
  },"24": {
    "doc": "Deployment - Highly-Available",
    "title": "FAQ",
    "content": "Why is this not automated? . Ansible would be a very good candidate to automate the installation of such an infrastructure on bare metal. We would be more than happy to review any PR on that matter. ",
    "url": "/docs/deployment/deployment-ha.html#faq",
    "relUrl": "/deployment/deployment-ha.html#faq"
  },"25": {
    "doc": "Deployment - Highly-Available",
    "title": "Deployment - Highly-Available",
    "content": " ",
    "url": "/docs/deployment/deployment-ha.html",
    "relUrl": "/deployment/deployment-ha.html"
  },"26": {
    "doc": "Deployment - Kubernetes",
    "title": "Deployment on Kubernetes",
    "content": ". UNDER CONSTRUCTION . ",
    "url": "/docs/deployment/deployment-kubernetes.html#deployment-on-kubernetes",
    "relUrl": "/deployment/deployment-kubernetes.html#deployment-on-kubernetes"
  },"27": {
    "doc": "Deployment - Kubernetes",
    "title": "FAQ",
    "content": "RAM usage . If using file-based authentication, the argon2id provider will by default use 1GB of RAM for password generation. This means you should allow for at least this amount in your deployment/daemonset spec and have this much available on your node, alternatively you can tweak the providers settings. Otherwise, your Authelia may OOM during login. See here for more info. ",
    "url": "/docs/deployment/deployment-kubernetes.html#faq",
    "relUrl": "/deployment/deployment-kubernetes.html#faq"
  },"28": {
    "doc": "Deployment - Kubernetes",
    "title": "Deployment - Kubernetes",
    "content": " ",
    "url": "/docs/deployment/deployment-kubernetes.html",
    "relUrl": "/deployment/deployment-kubernetes.html"
  },"29": {
    "doc": "Deployment - Lite",
    "title": "Lite Deployment",
    "content": "Authelia can be deployed as a lite setup with minimal external dependencies. The setup is called lite because it reduces the number of components in the architecture to a reverse proxy such as Nginx, Traefik or HAProxy, Authelia and Redis. This setup assumes you have basic knowledge and understanding of IP addresses, DNS and port forwarding. You should setup the domain you intend to protect with Authelia to point to your external IP address and port forward ports 80 and 443 to the host you plan to host the docker-compose.yml bundle. Port 80 is utilised by LetsEncrypt for certificate challenges, this will automatically provision up-to-date certificates for your domain(s). Traefik publishes the respective services with LetsEncrypt provided certificates on port 443. The provided examples protect the Traefik dashboard with Authelia’s one-factor auth (traefik.example.com) and two instances of the whoami container with Authelia being bypassed (public.example.com) and another with it’s two-factor auth (secure.example.com). If you happen to already have an external SQL instance (MariaDB, MySQL or Postgres) this setup can easily be adapted to utilise said service. ",
    "url": "/docs/deployment/deployment-lite.html#lite-deployment",
    "relUrl": "/deployment/deployment-lite.html#lite-deployment"
  },"30": {
    "doc": "Deployment - Lite",
    "title": "Steps",
    "content": ". | git clone https://github.com/authelia/authelia.git | cd authelia/compose/lite | Modify the users_database.yml the default username and password is authelia | Modify the configuration.yml and docker-compose.yml with your respective domains and secrets | docker-compose up -d | . ",
    "url": "/docs/deployment/deployment-lite.html#steps",
    "relUrl": "/deployment/deployment-lite.html#steps"
  },"31": {
    "doc": "Deployment - Lite",
    "title": "Reverse Proxy",
    "content": "The Lite bundle provides pre-made examples with Traefik2.x, you can swap this out for any of the supported proxies. ",
    "url": "/docs/deployment/deployment-lite.html#reverse-proxy",
    "relUrl": "/deployment/deployment-lite.html#reverse-proxy"
  },"32": {
    "doc": "Deployment - Lite",
    "title": "FAQ",
    "content": "Can you give more details on why this is not suitable for production environments? . This documentation gives instructions that will make Authelia non resilient to failures and non scalable by preventing you from running multiple instances of the application. This means that Authelia won’t be able to distribute the load across multiple servers and it will prevent failover in case of a crash or an hardware issue. ",
    "url": "/docs/deployment/deployment-lite.html#faq",
    "relUrl": "/deployment/deployment-lite.html#faq"
  },"33": {
    "doc": "Deployment - Lite",
    "title": "Deployment - Lite",
    "content": " ",
    "url": "/docs/deployment/deployment-lite.html",
    "relUrl": "/deployment/deployment-lite.html"
  },"34": {
    "doc": "Duo Push Notifications",
    "title": "Duo Push Notifications",
    "content": "Authelia supports mobile push notifications relying on Duo. Follow the instructions in the dedicated documentation to know how to set up push notifications in Authelia. ",
    "url": "/docs/configuration/duo-push-notifications.html",
    "relUrl": "/configuration/duo-push-notifications.html"
  },"35": {
    "doc": "Duo Push Notifications",
    "title": "Configuration",
    "content": "The configuration is as follows: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . The secret key is shown as an example, you also have the option to set it using an environment variable as described here. ",
    "url": "/docs/configuration/duo-push-notifications.html#configuration",
    "relUrl": "/configuration/duo-push-notifications.html#configuration"
  },"36": {
    "doc": "FAQ",
    "title": "Frequently asked questions",
    "content": " ",
    "url": "/docs/faq.html#frequently-asked-questions",
    "relUrl": "/faq.html#frequently-asked-questions"
  },"37": {
    "doc": "FAQ",
    "title": "How can the backend be aware of the authenticated users?",
    "content": "This question is solved here. ",
    "url": "/docs/faq.html#how-can-the-backend-be-aware-of-the-authenticated-users",
    "relUrl": "/faq.html#how-can-the-backend-be-aware-of-the-authenticated-users"
  },"38": {
    "doc": "FAQ",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/faq.html",
    "relUrl": "/faq.html"
  },"39": {
    "doc": "File",
    "title": "File",
    "content": "Authelia supports a file as a users database. ",
    "url": "/docs/configuration/authentication/file.html",
    "relUrl": "/configuration/authentication/file.html"
  },"40": {
    "doc": "File",
    "title": "Configuration",
    "content": "Configuring Authelia to use a file is done by specifying the path to the file in the configuration file. authentication_backend: # Disable both the HTML element and the API for reset password functionality disable_reset_password: false # File backend configuration. # # With this backend, the users database is stored in a file # which is updated when users reset their passwords. # Therefore, this backend is meant to be used in a dev environment # and not in production since it prevents Authelia to be scaled to # more than one instance. The options under 'password' have sane # defaults, and as it has security implications it is highly recommended # you leave the default values. Before considering changing these settings # please read the docs page below: # https://docs.authelia.com/configuration/authentication/file.html#password-hash-algorithm-tuning file: path: /config/users.yml password: algorithm: argon2id iterations: 1 salt_length: 16 parallelism: 8 memory: 64 . ",
    "url": "/docs/configuration/authentication/file.html#configuration",
    "relUrl": "/configuration/authentication/file.html#configuration"
  },"41": {
    "doc": "File",
    "title": "Format",
    "content": "The format of the users file is as follows. users: john: displayname: \"John Doe\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: john.doe@authelia.com groups: - admins - dev harry: displayname: \"Harry Potter\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: harry.potter@authelia.com groups: [] bob: displayname: \"Bob Dylan\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: bob.dylan@authelia.com groups: - dev james: displayname: \"James Dean\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: james.dean@authelia.com . This file should be set with read/write permissions as it could be updated by users resetting their passwords. ",
    "url": "/docs/configuration/authentication/file.html#format",
    "relUrl": "/configuration/authentication/file.html#format"
  },"42": {
    "doc": "File",
    "title": "Passwords",
    "content": "The file contains hashed passwords instead of plain text passwords for security reasons. You can use Authelia binary or docker image to generate the hash of any password. The hash-password command has many tunable options, you can view them with the authelia hash-password --help command. For example if you wanted to improve the entropy you could generate a 16 byte salt and provide it with the --salt flag. Example: authelia hash-password --salt abcdefghijklhijl. For argon2id the salt must always be valid for base64 decoding (characters a through z, A through Z, 0 through 9, and +/). Passwords passed to hash-password should be single quoted if using special characters to prevent parameter substitution. For instance to generate a hash with the docker image just run: . $ docker run authelia/authelia:latest authelia hash-password 'yourpassword' Password hash: $argon2id$v=19$m=65536$3oc26byQuSkQqksq$zM1QiTvVPrMfV6BVLs2t4gM+af5IN7euO0VB6+Q8ZFs . Full CLI Help Documentation: . Hash a password to be used in file-based users database. Default algorithm is argon2id. Usage: authelia hash-password [password] [flags] Flags: -h, --help help for hash-password -i, --iterations int set the number of hashing iterations (default 1) -k, --key-length int [argon2id] set the key length param (default 32) -m, --memory int [argon2id] set the amount of memory param (in MB) (default 64) -p, --parallelism int [argon2id] set the parallelism param (default 8) -s, --salt string set the salt string -l, --salt-length int set the auto-generated salt length (default 16) -z, --sha512 use sha512 as the algorithm (defaults iterations to 50000, change with -i) . ",
    "url": "/docs/configuration/authentication/file.html#passwords",
    "relUrl": "/configuration/authentication/file.html#passwords"
  },"43": {
    "doc": "File",
    "title": "Password hash algorithm",
    "content": "The default hash algorithm is Argon2id version 19 with a salt. Argon2id is currently considered the best hashing algorithm, and in 2015 won the Password Hashing Competition. It benefits from customizable parameters allowing the cost of computing a hash to scale into the future which makes it harder to brute-force. Argon2id was implemented due to community feedback as you can see in this closed issue. For backwards compatibility and user choice support for the SHA512 algorithm is still available. While it’s a reasonable hashing function given high enough iterations, as hardware improves it has a higher chance of being brute-forced. Hashes are identifiable as argon2id or SHA512 by their prefix of either $argon2id$ and $6$ respectively, as described in this wiki page. Important Note: When using argon2id Authelia will appear to remain using the memory allocated to creating the hash. This is due to how Go allocates memory to the heap when generating an argon2id hash. Go periodically garbage collects the heap, however this doesn’t remove the memory allocation, it keeps it allocated even though it’s technically unused. Under memory pressure the unused allocated memory will be reclaimed by the operating system, you can test this on linux with: . $ stress-ng --vm-bytes $(awk '/MemFree/{printf \"%d\\n\", $2 * 0.9;}' &lt; /proc/meminfo)k --vm-keep -m 1 . If this is not desirable we recommend investigating the following options in order of most to least secure: . | using the LDAP authentication provider | adjusting the memory parameter | changing the algorithm | . Password hash algorithm tuning . All algorithm tuning for Argon2id is supported. The only configuration variables that affect SHA512 are iterations and salt length. The configuration variables are unique to the file authentication provider, thus they all exist in a key under the file authentication configuration key called password. We have set what are considered as sane and recommended defaults to cater for a reasonable system, if you’re unsure about which settings to tune, please see the parameters below, or for a more in depth understanding see the referenced documentation in Argon2 links. Password hashing configuration settings . algorithm . | Value Type: String | Possible Value: argon2id or sha512 | Recommended: argon2id | What it Does: Changes the hashing algorithm | . iterations . | Value Type: Int | Possible Value: 1 or higher for argon2id and 1000 or higher for sha512 (will automatically be set to 1000 on lower settings) | Recommended: 1 for the argon2id algorithm and 50000 for sha512 | What it Does: Adjusts the number of times we run the password through the hashing algorithm | . key_length . | Value Type: Int | Possible Value: 16 or higher. | Recommended: 32 or higher. | What it Does: Adjusts the length of the actual hash | . salt_length . | Value Type: Int | Possible Value: 8 or higher. | Recommended: 16 | What it Does: Adjusts the length of the random salt we add to the password, there is no reason not to set this to 16 | . parallelism . | Value Type: Int | Possible Value: 1 or higher | Recommended: 8 or twice your CPU cores | What it Does: Sets the number of threads used for hashing | . memory . | Value Type: Int | Possible Value: at least 8 times the value of parallelism | Recommended: 64 (64MB) or as much RAM as you can afford to give to hashing | What it Does: Sets the amount of RAM used in MB for hashing | . Examples for specific systems . These examples have been tested against a single system to make sure they roughly take 0.5 seconds each. Your results may vary depending on individual specification and utilization, but they are a good guide to get started. You should however read the linked documents in Argon2 links. | System | Iterations | Parallelism | Memory | . | Raspberry Pi 2 | 1 | 8 | 64 | . | Raspberry Pi 3 | 1 | 8 | 128 | . | Raspberry Pi 4 | 1 | 8 | 128 | . | Intel G5 i5 NUC | 1 | 8 | 1024 | . Argon2 Links . How to choose the right parameters for Argon2 . Go Documentation . IETF Draft . ",
    "url": "/docs/configuration/authentication/file.html#password-hash-algorithm",
    "relUrl": "/configuration/authentication/file.html#password-hash-algorithm"
  },"44": {
    "doc": "Filesystem",
    "title": "Filesystem",
    "content": "With this configuration, the message will be sent to a file. This option should only be used for testing purposes. This method will use the plain text email template for readability purposes. # Configuration of the notification system. # # Notifications are sent to users when they require a password reset, a U2F # registration or a TOTP registration. # Use only an available configuration: filesystem, smtp. notifier: # You can disable the notifier startup check by setting this to true. disable_startup_check: false # For testing purpose, notifications can be sent in a file. filesystem: filename: /config/notification.txt . ",
    "url": "/docs/configuration/notifier/filesystem.html",
    "relUrl": "/configuration/notifier/filesystem.html"
  },"45": {
    "doc": "First Factor",
    "title": "First Factor",
    "content": "2-Factor authentication is a method in which a user is granted access by presenting two pieces of evidence that she is who she claims to be. Authelia requires usual username and password as a first factor. IMPORTANT: This is currently the only method available as first factor. Using other methods will likely be possible when WebAuthN is implemented . Authelia supports several kind of users databases: . | An LDAP server like OpenLDAP or OpenAM. | An Active Directory. | A YAML file | . ",
    "url": "/docs/features/first-factor.html",
    "relUrl": "/features/first-factor.html"
  },"46": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/docs/getting-started.html",
    "relUrl": "/getting-started.html"
  },"47": {
    "doc": "Getting Started",
    "title": "Docker Compose",
    "content": "Steps . These commands are intended to be run sequentially: . | git clone https://github.com/authelia/authelia.git | cd authelia/compose/local | sudo ./setup.sh sudo is required to modify the /etc/hosts file | . You can now visit the following locations; replace example.com with the domain you specified in the setup script: . | https://public.example.com - Bypasses Authelia | https://traefik.example.com - Secured with Authelia one-factor authentication | https://secure.example.com - Secured with Authelia two-factor authentication (see note below) | . You will need to authorize the self-signed certificate upon visiting each domain. To visit https://secure.example.com you will need to register a device for second factor authentication and confirm by clicking on a link sent by email. Since this is a demo with a fake email address, the content of the email will be stored in ./authelia/notification.txt. Upon registering, you can grab this link easily by running the following command: grep -Eo '\"https://.*\" ' ./authelia/notification.txt. ",
    "url": "/docs/getting-started.html#docker-compose",
    "relUrl": "/getting-started.html#docker-compose"
  },"48": {
    "doc": "Getting Started",
    "title": "Deployment",
    "content": "So you’re convinced that Authelia is what you need. You can head to the deployment documentation here. Some recipes have been crafted for helping with the bootstrap of your environment. You can choose between a lite deployment which is deployment advised for a single server setup. However, this setup just does not scale. If you want a full environment that can scale out, use the HA or Kubernetes deployment documentation. ",
    "url": "/docs/getting-started.html#deployment",
    "relUrl": "/getting-started.html#deployment"
  },"49": {
    "doc": "HAProxy",
    "title": "HAProxy",
    "content": "HAProxy is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/haproxy.html",
    "relUrl": "/deployment/supported-proxies/haproxy.html"
  },"50": {
    "doc": "HAProxy",
    "title": "Requirements",
    "content": "You need the following to run Authelia with HAProxy: . | HAProxy 1.8.4+ (2.2.0+ recommended) . | USE_LUA=1 set at compile time | haproxy-lua-http must be available within the Lua path . | A json library within the Lua path (dependency of haproxy-lua-http, usually found as OS package lua-json) | With HAProxy 2.1.3+ you can use the [lua-prepend-path] configuration option to specify the search path. | . | haproxy-auth-request | . | . ",
    "url": "/docs/deployment/supported-proxies/haproxy.html#requirements",
    "relUrl": "/deployment/supported-proxies/haproxy.html#requirements"
  },"51": {
    "doc": "HAProxy",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Authelia portal | Protected endpoint (Nextcloud) | Protected endpoint with Authorization header for basic authentication (Heimdall) | haproxy-auth-request | . With this configuration you can protect your virtual hosts with Authelia, by following the steps below: . | Add host(s) to the protected-frontends or protected-frontends-basic ACLs to support protection with Authelia. You can separate each subdomain with a | in the regex, for example: acl protected-frontends hdr(host) -m reg -i ^(?i)(jenkins|nextcloud|phpmyadmin)\\.example\\.com acl protected-frontends-basic hdr(host) -m reg -i ^(?i)(heimdall)\\.example\\.com . | Add host ACL(s) in the form of host-service, this will be utilised to route to the correct backend upon successful authentication, for example: acl host-jenkins hdr(host) -i jenkins.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com acl host-phpmyadmin hdr(host) -i phpmyadmin.example.com acl host-heimdall hdr(host) -i heimdall.example.com . | Add backend route for your service(s), for example: use_backend be_jenkins if host-jenkins use_backend be_nextcloud if host-nextcloud use_backend be_phpmyadmin if host-phpmyadmin use_backend be_heimdall if host-heimdall . | Add backend definitions for your service(s), for example: backend be_jenkins server jenkins jenkins:8080 backend be_nextcloud server nextcloud nextcloud:443 ssl verify none backend be_phpmyadmin server phpmyadmin phpmyadmin:80 backend be_heimdall server heimdall heimdall:443 ssl verify none . | . Secure Authelia with TLS . There is a known limitation with haproxy-auth-request with regard to TLS-enabled backends. If you want to run Authelia TLS enabled the recommended workaround utilises HAProxy itself to proxy the requests. This comes at a cost of two additional TCP connections, but allows the full HAProxy configuration flexibility with regard to TLS verification as well as header rewriting. An example of this configuration is also be provided below. Configuration . haproxy.cfg . global # Path to haproxy-lua-http, below example assumes /usr/local/etc/haproxy/haproxy-lua-http/http.lua lua-prepend-path /usr/local/etc/haproxy/?/http.lua # Path to haproxy-auth-request lua-load /usr/local/etc/haproxy/auth-request.lua log stdout format raw local0 debug defaults mode http log global option httplog option forwardfor frontend fe_http bind *:443 ssl crt /usr/local/etc/haproxy/haproxy.pem # Host ACLs acl protected-frontends hdr(host) -m reg -i ^(?i)(nextcloud)\\.example\\.com acl protected-frontends-basic hdr(host) -m reg -i ^(?i)(heimdall)\\.example\\.com acl host-authelia hdr(host) -i auth.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com acl host-heimdall hdr(host) -i heimdall.example.com # This is required if utilising basic auth with /api/verify?auth=basic http-request set-var(txn.host) hdr(Host) http-request set-var(req.scheme) str(https) if { ssl_fc } http-request set-var(req.scheme) str(http) if !{ ssl_fc } http-request set-var(req.questionmark) str(?) if { query -m found } # These are optional if you wish to use the Methods rule in the access_control section. #http-request set-var(req.method) str(CONNECT) if { method CONNECT } #http-request set-var(req.method) str(GET) if { method GET } #http-request set-var(req.method) str(HEAD) if { method HEAD } #http-request set-var(req.method) str(OPTIONS) if { method OPTIONS } #http-request set-var(req.method) str(POST) if { method POST } #http-request set-var(req.method) str(TRACE) if { method TRACE } #http-request set-var(req.method) str(PUT) if { method PUT } #http-request set-var(req.method) str(PATCH) if { method PATCH } #http-request set-var(req.method) str(DELETE) if { method DELETE } #http-request set-header X-Forwarded-Method %[var(req.method)] # Required headers http-request set-header X-Real-IP %[src] http-request set-header X-Forwarded-Method %[var(req.method)] http-request set-header X-Forwarded-Proto %[var(req.scheme)] http-request set-header X-Forwarded-Host %[req.hdr(Host)] http-request set-header X-Forwarded-Uri %[path]%[var(req.questionmark)]%[query] # Protect endpoints with haproxy-auth-request and Authelia http-request lua.auth-request be_authelia /api/verify if protected-frontends # Force `Authorization` header via query arg to /api/verify http-request lua.auth-request be_authelia /api/verify?auth=basic if protected-frontends-basic # Redirect protected-frontends to Authelia if not authenticated http-request redirect location https://auth.example.com/?rd=%[var(req.scheme)]://%[base]%[var(req.questionmark)]%[query] if protected-frontends !{ var(txn.auth_response_successful) -m bool } # Send 401 and pass `WWW-Authenticate` header on protected-frontend-basic if not pre-authenticated http-request set-var(txn.auth) var(req.auth_response_header.www_authenticate) if protected-frontends-basic !{ var(txn.auth_response_successful) -m bool } http-response deny deny_status 401 hdr WWW-Authenticate %[var(txn.auth)] if { var(txn.host) -m reg -i ^(?i)(heimdall)\\.example\\.com } !{ var(txn.auth_response_successful) -m bool } # Authelia backend route use_backend be_authelia if host-authelia # Service backend route(s) use_backend be_nextcloud if host-nextcloud use_backend be_heimdall if host-heimdall backend be_authelia server authelia authelia:9091 backend be_nextcloud # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server nextcloud nextcloud:443 ssl verify none backend be_heimdall # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server heimdall heimdall:443 ssl verify none . haproxy.cfg (TLS enabled Authelia) . global # Path to haproxy-lua-http, below example assumes /usr/local/etc/haproxy/haproxy-lua-http/http.lua lua-prepend-path /usr/local/etc/haproxy/?/http.lua # Path to haproxy-auth-request lua-load /usr/local/etc/haproxy/auth-request.lua log stdout format raw local0 debug defaults mode http log global option httplog option forwardfor frontend fe_http bind *:443 ssl crt /usr/local/etc/haproxy/haproxy.pem # Host ACLs acl protected-frontends hdr(host) -m reg -i ^(?i)(nextcloud)\\.example\\.com acl protected-frontends-basic hdr(host) -m reg -i ^(?i)(heimdall)\\.example\\.com acl host-authelia hdr(host) -i auth.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com acl host-heimdall hdr(host) -i heimdall.example.com # This is required if utilising basic auth with /api/verify?auth=basic http-request set-var(txn.host) hdr(Host) http-request set-var(req.scheme) str(https) if { ssl_fc } http-request set-var(req.scheme) str(http) if !{ ssl_fc } http-request set-var(req.questionmark) str(?) if { query -m found } # These are optional if you wish to use the Methods rule in the access_control section. #http-request set-var(req.method) str(CONNECT) if { method CONNECT } #http-request set-var(req.method) str(GET) if { method GET } #http-request set-var(req.method) str(HEAD) if { method HEAD } #http-request set-var(req.method) str(OPTIONS) if { method OPTIONS } #http-request set-var(req.method) str(POST) if { method POST } #http-request set-var(req.method) str(TRACE) if { method TRACE } #http-request set-var(req.method) str(PUT) if { method PUT } #http-request set-var(req.method) str(PATCH) if { method PATCH } #http-request set-var(req.method) str(DELETE) if { method DELETE } #http-request set-header X-Forwarded-Method %[var(req.method)] # Required headers http-request set-header X-Real-IP %[src] http-request set-header X-Forwarded-Proto %[var(req.scheme)] http-request set-header X-Forwarded-Host %[req.hdr(Host)] http-request set-header X-Forwarded-Uri %[path]%[var(req.questionmark)]%[query] # Protect endpoints with haproxy-auth-request and Authelia http-request lua.auth-request be_authelia_proxy /api/verify if protected-frontends # Force `Authorization` header via query arg to /api/verify http-request lua.auth-request be_authelia_proxy /api/verify?auth=basic if protected-frontends-basic # Redirect protected-frontends to Authelia if not authenticated http-request redirect location https://auth.example.com/?rd=%[var(req.scheme)]://%[base]%[var(req.questionmark)]%[query] if protected-frontends !{ var(txn.auth_response_successful) -m bool } # Send 401 and pass `WWW-Authenticate` header on protected-frontend-basic if not pre-authenticated http-request set-var(txn.auth) var(req.auth_response_header.www_authenticate) if protected-frontends-basic !{ var(txn.auth_response_successful) -m bool } http-response deny deny_status 401 hdr WWW-Authenticate %[var(txn.auth)] if { var(txn.host) -m reg -i ^(?i)(heimdall)\\.example\\.com } !{ var(txn.auth_response_successful) -m bool } # Authelia backend route use_backend be_authelia if host-authelia # Service backend route(s) use_backend be_nextcloud if host-nextcloud use_backend be_heimdall if host-heimdall backend be_authelia server authelia authelia:9091 backend be_authelia_proxy mode http server proxy 127.0.0.1:9092 listen authelia_proxy mode http bind 127.0.0.1:9092 server authelia authelia:9091 ssl verify none backend be_nextcloud # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server nextcloud nextcloud:443 ssl verify none backend be_heimdall # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server heimdall heimdall:443 ssl verify none . ",
    "url": "/docs/deployment/supported-proxies/haproxy.html#configuration",
    "relUrl": "/deployment/supported-proxies/haproxy.html#configuration"
  },"52": {
    "doc": "Proxy Integration",
    "title": "Integration with proxies",
    "content": "Authelia works in collaboration with reverse proxies. In the sub-pages you can find the documentation of the configuration required for every supported proxy. If you are not aware of the workflow of an authentication request, reading this documentation first is highly recommended. ",
    "url": "/docs/deployment/supported-proxies/#integration-with-proxies",
    "relUrl": "/deployment/supported-proxies/#integration-with-proxies"
  },"53": {
    "doc": "Proxy Integration",
    "title": "How Authelia integrates with proxies?",
    "content": "Authelia takes authentication requests coming from the proxy and targeting the /api/verify endpoint exposed by Authelia. Two pieces of information are required for Authelia to be able to authenticate the user request: . | The session cookie or a Proxy-Authorization header (see single factor authentication). | The target URL of the user request (used primarily for access control). | . The target URL can be provided using one of the following ways: . | With X-Original-URL header containing the complete URL of the initial request. | With a combination of X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-URI headers. | . In the case of Traefik, these headers are automatically provided and therefore don’t appear in the configuration examples. ",
    "url": "/docs/deployment/supported-proxies/#how-authelia-integrates-with-proxies",
    "relUrl": "/deployment/supported-proxies/#how-authelia-integrates-with-proxies"
  },"54": {
    "doc": "Proxy Integration",
    "title": "How can the backend be aware of the authenticated users?",
    "content": "The only way Authelia can share information about the authenticated user currently is through the use of four HTTP headers: Remote-User, Remote-Name, Remote-Email and Remote-Groups. Those headers are returned by Authelia on requests to /api/verify and must be forwarded by the reverse proxy to the backends needing them. The headers will be provided with each call to the backend once the user is authenticated. Please note that the backend must support the use of those headers to leverage that information, many backends still don’t (and probably won’t) support it. However, we are working on solving this issue with OpenID Connect/OAuth2 which is a widely adopted open standard for access delegation. So, if you’re developing your own application, you can read those headers and use them. If you don’t own the codebase of the backend, you need to check whether it supports this type of authentication or not. If it does not, you have three options: . | Enable authentication on the backend and make your users authenticate twice (not user-friendly). | Completely disable the authentication of your backend. This works only if all your users share the same privileges in the backend. | Many applications support OAuth2 so the last option would be to just wait for Authelia to be an OpenID Connect provider (https://github.com/authelia/authelia/issues/189). | . ",
    "url": "/docs/deployment/supported-proxies/#how-can-the-backend-be-aware-of-the-authenticated-users",
    "relUrl": "/deployment/supported-proxies/#how-can-the-backend-be-aware-of-the-authenticated-users"
  },"55": {
    "doc": "Proxy Integration",
    "title": "Redirection to the login portal",
    "content": "The endpoint /api/verify has different behaviors depending on whether the rd (for redirection) query parameter is provided. If redirection parameter is provided and contains the URL to the login portal served by Authelia, the request will either generate a 200 response if the request is authenticated or perform a redirection (302 response) to the login portal if not authenticated yet. If no redirection parameter is provided, the response code is either 200 or 401. The redirection must then be handled by the proxy when an error is detected (see nginx example). ",
    "url": "/docs/deployment/supported-proxies/#redirection-to-the-login-portal",
    "relUrl": "/deployment/supported-proxies/#redirection-to-the-login-portal"
  },"56": {
    "doc": "Proxy Integration",
    "title": "Proxy Integration",
    "content": " ",
    "url": "/docs/deployment/supported-proxies/",
    "relUrl": "/deployment/supported-proxies/"
  },"57": {
    "doc": "Authentication backends",
    "title": "Authentication Backends",
    "content": "There are two ways to store the users along with their password: . | LDAP: users are stored in remote servers like OpenLDAP, OpenAM or Microsoft Active Directory. | File: users are stored in YAML file with a hashed version of their password. | . ",
    "url": "/docs/configuration/authentication/#authentication-backends",
    "relUrl": "/configuration/authentication/#authentication-backends"
  },"58": {
    "doc": "Authentication backends",
    "title": "Disabling Reset Password",
    "content": "You can disable the reset password functionality for additional security as per this configuration: . # The authentication backend to use for verifying user passwords # and retrieve information such as email address and groups # users belong to. # # There are two supported backends: 'ldap' and 'file'. authentication_backend: # Disable both the HTML element and the API for reset password functionality disable_reset_password: true . ",
    "url": "/docs/configuration/authentication/#disabling-reset-password",
    "relUrl": "/configuration/authentication/#disabling-reset-password"
  },"59": {
    "doc": "Authentication backends",
    "title": "Authentication backends",
    "content": " ",
    "url": "/docs/configuration/authentication/",
    "relUrl": "/configuration/authentication/"
  },"60": {
    "doc": "Features",
    "title": "Features",
    "content": "Authelia is a 2FA &amp; SSO authentication server which is dedicated to the security of applications and users. It can be considered as an extension of reverse proxies by providing features specific to authentication. You will find among other features: . | Multiple two-factor methods. | Identity verification when registering second factor devices. | Reset password. | Ban account after too many attempts (known as regulation). | . ",
    "url": "/docs/features/",
    "relUrl": "/features/"
  },"61": {
    "doc": "Contributing",
    "title": "Contributing",
    "content": " ",
    "url": "/docs/contributing/",
    "relUrl": "/contributing/"
  },"62": {
    "doc": "Contributing",
    "title": "Development workflow",
    "content": "Authelia and its development workflow can be tested with Docker and docker-compose on Linux. In order to deploy the current version of Authelia locally, run the following command and follow the instructions of bootstrap.sh: . $ source bootstrap.sh . Then, start the Standalone suite. $ authelia-scripts suites setup Standalone . A suite is kind of a virtual environment for running Authelia in a complete ecosystem. If you want more details please read the related documentation. ",
    "url": "/docs/contributing/#development-workflow",
    "relUrl": "/contributing/#development-workflow"
  },"63": {
    "doc": "Contributing",
    "title": "FAQ",
    "content": "What version of Docker and docker-compose should I use? . Here are the versions used for testing in Buildkite: . $ docker --version Docker version 19.03.5, build 633a0ea838 $ docker-compose --version docker-compose version 1.24.1, build unknown . How can I serve my application under example.com? . Don’t worry, you don’t need to own the domain example.com to test Authelia. Copy the following lines in your /etc/hosts. 192.168.240.100 home.example.com 192.168.240.100 login.example.com 192.168.240.100 singlefactor.example.com 192.168.240.100 public.example.com 192.168.240.100 secure.example.com 192.168.240.100 mail.example.com 192.168.240.100 mx1.mail.example.com . 192.168.240.100 is the IP attributed by Docker to the reverse proxy. Once added you can access the listed sub-domains from your browser, and they will target the reverse proxy. ",
    "url": "/docs/contributing/#faq",
    "relUrl": "/contributing/#faq"
  },"64": {
    "doc": "Storage backends",
    "title": "Storage backends",
    "content": "Authelia supports multiple storage backends. The backend is used to store user preferences, 2FA device handles and secrets, authentication logs, etc… . The available options are: . | MariaDB | MySQL | Postgres | SQLite | . ",
    "url": "/docs/configuration/storage/",
    "relUrl": "/configuration/storage/"
  },"65": {
    "doc": "Home",
    "title": "Home",
    "content": "It has never been so easy to secure your applications with Single Sign-On and Two-Factor. With Authelia you can login once and get access to all your web apps safely from the Web thanks to two-factor authentication. Authelia is an open source authentication and authorization server protecting modern web applications by collaborating with reverse proxies such as NGINX, Traefik and HAProxy. Consequently, no code is required to protect your apps. Multiple 2-factor methods are available for satisfying every users. | Time-based One-Time passwords with Google Authenticator. | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . Authelia is available as Docker images, static binaries and AUR packages so that you can test it in minutes. Let’s begin with the Getting Started. ",
    "url": "/docs/",
    "relUrl": "/"
  },"66": {
    "doc": "Home",
    "title": "However, Authelia…",
    "content": ". | is not an OAuth or OpenID Connect provider yet (planned in the roadmap) | is not a SAML provider yet. | does not support authentication against an OAuth or OpenID Connect provider yet. | does not support authentication against a SAML provider yet. | does not support using hardware devices as single factor. | does not provide a PAM module yet. | . ",
    "url": "/docs/#however-authelia",
    "relUrl": "/#however-authelia"
  },"67": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "Authelia uses a YAML file as configuration file. A template with all possible options can be found here, at the root of the repository. When running Authelia, you can specify your configuration by passing the file path as shown below. $ authelia --config config.custom.yml . ",
    "url": "/docs/configuration/",
    "relUrl": "/configuration/"
  },"68": {
    "doc": "Configuration",
    "title": "Validation",
    "content": "Authelia validates the configuration when it starts. This process checks multiple factors including configuration keys that don’t exist, configuration keys that have changed, the values of the keys are valid, and that a configuration key isn’t supplied at the same time as a secret for the same configuration option. You may also optionally validate your configuration against this validation process manually by using the validate-config option with the Authelia binary as shown below. Keep in mind if you’re using secrets you will have to manually provide these if you don’t want to get certain validation errors (specifically requesting you provide one of the secret values). You can choose to ignore them if you know what you’re doing. This command is useful prior to upgrading to prevent configuration changes from impacting downtime in an upgrade. This process does not validate integrations, it only checks that your configuration syntax is valid. $ authelia validate-config configuration.yml . ",
    "url": "/docs/configuration/#validation",
    "relUrl": "/configuration/#validation"
  },"69": {
    "doc": "Configuration",
    "title": "Duration Notation Format",
    "content": "We have implemented a string based notation for configuration options that take a duration. This section describes its usage. You can use this implementation in: session for expiration, inactivity, and remember_me_duration; and regulation for ban_time, and find_time. This notation also supports just providing the number of seconds instead. The notation is comprised of a number which must be positive and not have leading zeros, followed by a letter denoting the unit of time measurement. The table below describes the units of time and the associated letter. | Unit | Associated Letter | . | Years | y | . | Months | M | . | Weeks | w | . | Days | d | . | Hours | h | . | Minutes | m | . | Seconds | s | . Examples: . | 1 hour and 30 minutes: 90m | 1 day: 1d | 10 hours: 10h | . ",
    "url": "/docs/configuration/#duration-notation-format",
    "relUrl": "/configuration/#duration-notation-format"
  },"70": {
    "doc": "Configuration",
    "title": "TLS Configuration",
    "content": "Various sections of the configuration use a uniform configuration section called TLS. Notably LDAP and SMTP. This section documents the usage. Server Name . The key server_name overrides the name checked against the certificate in the verification process. Useful if you require to use a direct IP address for the address of the backend service but want to verify a specific SNI. Skip Verify . The key skip_verify completely negates validating the certificate of the backend service. This is not recommended, instead you should tweak the server_name option, and the global option certificates_directory. Minimum Version . The key minimum_version controls the minimum TLS version Authelia will use when opening TLS connections. The possible values are TLS1.3, TLS1.2, TLS1.1, TLS1.0. Anything other than TLS1.3 or TLS1.2 are very old and deprecated. You should avoid using these and upgrade your backend service instead of decreasing this value. ",
    "url": "/docs/configuration/#tls-configuration",
    "relUrl": "/configuration/#tls-configuration"
  },"71": {
    "doc": "Deployment",
    "title": "Deployment",
    "content": " ",
    "url": "/docs/deployment/",
    "relUrl": "/deployment/"
  },"72": {
    "doc": "Notifier",
    "title": "Notifier",
    "content": "Authelia sometimes needs to send messages to users in order to verify their identity. ",
    "url": "/docs/configuration/notifier/",
    "relUrl": "/configuration/notifier/"
  },"73": {
    "doc": "Notifier",
    "title": "Startup Check",
    "content": "The notifier has a startup check which validates the specified provider configuration is correct and will be able to send emails. This can be disabled with the disable_startup_check option: . # Configuration of the notification system. # # Notifications are sent to users when they require a password reset, a u2f # registration or a TOTP registration. # Use only an available configuration: filesystem, smtp. notifier: # You can disable the notifier startup check by setting this to true disable_startup_check: false . ",
    "url": "/docs/configuration/notifier/#startup-check",
    "relUrl": "/configuration/notifier/#startup-check"
  },"74": {
    "doc": "Second Factor",
    "title": "Second Factor",
    "content": "There are multiple supported options for the second factor. | Time-based One-Time passwords with Google Authenticator | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . ",
    "url": "/docs/features/2fa/",
    "relUrl": "/features/2fa/"
  },"75": {
    "doc": "Community",
    "title": "Community documentation",
    "content": "This section is meant to advertise and organize documentation produced by the community. This documentation is considered non-official and we will not guarantee that this documentation is up-to-date. If you think some of it should be considered official, please file an issue on Github. ",
    "url": "/docs/community/#community-documentation",
    "relUrl": "/community/#community-documentation"
  },"76": {
    "doc": "Community",
    "title": "Community",
    "content": " ",
    "url": "/docs/community/",
    "relUrl": "/community/"
  },"77": {
    "doc": "Security",
    "title": "Security",
    "content": "Authelia takes security very seriously. We follow the rule of responsible disclosure, and we encourage the community to as well. If you discover a vulnerability in Authelia, please first contact one of the maintainers privately either via Matrix or email as described in the contact options below. For details about security measures implemented in Authelia, please follow this link and for reading about the threat model follow this link. ",
    "url": "/docs/security/",
    "relUrl": "/security/"
  },"78": {
    "doc": "Security",
    "title": "Contact Options",
    "content": "Matrix . Join the Matrix Room and locate one of the maintainers. You can identify them as they are the room administrators. Alternatively you can just ask for one of the maintainers. Once you’ve made contact we ask you privately message the maintainer to communicate the vulnerability. Email . You can contact any of the maintainers for security vulnerability related issues by emailing security@authelia.com. This email is strictly reserved for security and vulnerability disclosure related matters. If you need to contact us for another reason please use Matrix or team@authelia.com. ",
    "url": "/docs/security/#contact-options",
    "relUrl": "/security/#contact-options"
  },"79": {
    "doc": "LDAP",
    "title": "LDAP",
    "content": "Authelia supports using a LDAP server as the users database. ",
    "url": "/docs/configuration/authentication/ldap.html",
    "relUrl": "/configuration/authentication/ldap.html"
  },"80": {
    "doc": "LDAP",
    "title": "Configuration",
    "content": "Configuration of the LDAP backend is done as follows . # The authentication backend to use for verifying user passwords # and retrieve information such as email address and groups # users belong to. # # There are two supported backends: 'ldap' and 'file'. authentication_backend: # Disable both the HTML element and the API for reset password functionality disable_reset_password: false # The amount of time to wait before we refresh data from the authentication backend. Uses duration notation. # To disable this feature set it to 'disable', this will slightly reduce security because for Authelia, users # will always belong to groups they belonged to at the time of login even if they have been removed from them in LDAP. # To force update on every request you can set this to '0' or 'always', this will increase processor demand. # See the below documentation for more information. # Duration Notation docs: https://docs.authelia.com/configuration/index.html#duration-notation-format # Refresh Interval docs: https://docs.authelia.com/configuration/authentication/ldap.html#refresh-interval refresh_interval: 5m # LDAP backend configuration. # # This backend allows Authelia to be scaled to more # than one instance and therefore is recommended for # production. ldap: # The LDAP implementation, this affects elements like the attribute utilised for resetting a password. # Acceptable options are as follows: # - 'activedirectory' - For Microsoft Active Directory. # - 'custom' - For custom specifications of attributes and filters. # This currently defaults to 'custom' to maintain existing behaviour. # # Depending on the option here certain other values in this section have a default value, notably all # of the attribute mappings have a default value that this config overrides, you can read more # about these default values at https://docs.authelia.com/configuration/authentication/ldap.html#defaults implementation: custom # The url to the ldap server. Scheme can be ldap or ldaps in the format (port optional) &lt;scheme&gt;://&lt;address&gt;[:&lt;port&gt;]. url: ldap://127.0.0.1 # Use StartTLS with the LDAP connection. start_tls: false tls: # Server Name for certificate validation (in case it's not set correctly in the URL). # server_name: ldap.example.com # Skip verifying the server certificate (to allow a self-signed certificate). skip_verify: false # Minimum TLS version for either Secure LDAP or LDAP StartTLS. minimum_version: TLS1.2 # The base dn for every entries. base_dn: dc=example,dc=com # The attribute holding the username of the user. This attribute is used to populate # the username in the session information. It was introduced due to #561 to handle case # insensitive search queries. # For you information, Microsoft Active Directory usually uses 'sAMAccountName' and OpenLDAP # usually uses 'uid' # Beware that this attribute holds the unique identifiers for the users binding the user and the configuration # stored in database. Therefore only single value attributes are allowed and the value # must never be changed once attributed to a user otherwise it would break the configuration # for that user. Technically, non-unique attributes like 'mail' can also be used but we don't recommend using # them, we instead advise to use the attributes mentioned above (sAMAccountName and uid) to follow # https://www.ietf.org/rfc/rfc2307.txt. # username_attribute: uid # An additional dn to define the scope to all users. additional_users_dn: ou=users # The users filter used in search queries to find the user profile based on input filled in login form. # Various placeholders are available to represent the user input and back reference other options of the configuration: # - {input} is a placeholder replaced by what the user inputs in the login form. # - {username_attribute} is a mandatory placeholder replaced by what is configured in `username_attribute`. # - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`. # - DON'T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later versions, so please don't use it. # # Recommended settings are as follows: # - Microsoft Active Directory: (&amp;({username_attribute}={input})(objectCategory=person)(objectClass=user)) # - OpenLDAP: (&amp;({username_attribute}={input})(objectClass=person))' or '(&amp;({username_attribute}={input})(objectClass=inetOrgPerson)) # # To allow sign in both with username and email, one can use a filter like # (&amp;(|({username_attribute}={input})({mail_attribute}={input}))(objectClass=person)) users_filter: (&amp;({username_attribute}={input})(objectClass=person)) # An additional dn to define the scope of groups. additional_groups_dn: ou=groups # The groups filter used in search queries to find the groups of the user. # - {input} is a placeholder replaced by what the user inputs in the login form. # - {username} is a placeholder replace by the username stored in LDAP (based on `username_attribute`). # - {dn} is a matcher replaced by the user distinguished name, aka, user DN. # - {username_attribute} is a placeholder replaced by what is configured in `username_attribute`. # - {mail_attribute} is a placeholder replaced by what is configured in `mail_attribute`. # - DON'T USE - {0} is an alias for {input} supported for backward compatibility but it will be deprecated in later versions, so please don't use it. # - DON'T USE - {1} is an alias for {username} supported for backward compatibility but it will be deprecated in later version, so please don't use it. # If your groups use the `groupOfUniqueNames` structure use this instead: (&amp;(uniquemember={dn})(objectclass=groupOfUniqueNames)) groups_filter: (&amp;(member={dn})(objectclass=groupOfNames)) # The attribute holding the name of the group # group_name_attribute: cn # The attribute holding the mail address of the user. If multiple email addresses are defined for a user, only the first # one returned by the LDAP server is used. # mail_attribute: mail # The attribute holding the display name of the user. This will be used to greet an authenticated user. # display_name_attribute: displayname # The username and password of the admin user. user: cn=admin,dc=example,dc=com # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: password . The user must have an email address in order for Authelia to perform identity verification when a user attempts to reset their password or register a second factor device. ",
    "url": "/docs/configuration/authentication/ldap.html#configuration",
    "relUrl": "/configuration/authentication/ldap.html#configuration"
  },"81": {
    "doc": "LDAP",
    "title": "IPv6 Addresses",
    "content": "If utilising an IPv6 literal address it must be enclosed by square brackets: . url: ldap://[fd00:1111:2222:3333::1] . ",
    "url": "/docs/configuration/authentication/ldap.html#ipv6-addresses",
    "relUrl": "/configuration/authentication/ldap.html#ipv6-addresses"
  },"82": {
    "doc": "LDAP",
    "title": "TLS Settings",
    "content": "Start TLS . The key start_tls enables use of the LDAP StartTLS process which is not commonly used. You should only configure this if you know you need it. The initial connection will be over plain text, and Authelia will try to upgrade it with the LDAP server. LDAPS URL’s are slightly more secure. TLS (section) . The key tls is a map of options for tuning TLS options. You can see how to configure the tls section here. ",
    "url": "/docs/configuration/authentication/ldap.html#tls-settings",
    "relUrl": "/configuration/authentication/ldap.html#tls-settings"
  },"83": {
    "doc": "LDAP",
    "title": "Implementation",
    "content": "There are currently two implementations, custom and activedirectory. The activedirectory implementation must be used if you wish to allow users to change or reset their password as Active Directory uses a custom attribute for this, and an input format other implementations do not use. The long term intention of this is to have logical defaults for various RFC implementations of LDAP. Defaults . The below tables describes the current attribute defaults for each implementation. Attributes . This table describes the attribute defaults for each implementation. i.e. the username_attribute is described by the Username column. | Implementation | Username | Display Name | Mail | Group Name | . | custom | n/a | displayname | mail | cn | . | activedirectory | sAMAccountName | displayname | mail | cn | . Filters . The filters are probably the most important part to get correct when setting up LDAP. You want to exclude disabled accounts. The active directory example has two attribute filters that accomplish this as an example (more examples would be appreciated). The userAccountControl filter checks that the account is not disabled and the pwdLastSet makes sure that value is not 0 which means the password requires changing at the next login. | Implementation | Users Filter | Groups Filter | . | custom | n/a | n/a | . | activedirectory | (&amp;(|({username_attribute}={input})({mail_attribute}={input}))(objectCategory=person)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(!pwdLastSet=0)) | (&amp;(member={dn})(objectClass=group)(objectCategory=group)) | . ",
    "url": "/docs/configuration/authentication/ldap.html#implementation",
    "relUrl": "/configuration/authentication/ldap.html#implementation"
  },"84": {
    "doc": "LDAP",
    "title": "Refresh Interval",
    "content": "This setting takes a duration notation that sets the max frequency for how often Authelia contacts the backend to verify the user still exists and that the groups stored in the session are up to date. This allows us to destroy sessions when the user no longer matches the user_filter, or deny access to resources as they are removed from groups. In addition to the duration notation, you may provide the value always or disable. Setting to always is the same as setting it to 0 which will refresh on every request, disable turns the feature off, which is not recommended. This completely prevents Authelia from refreshing this information, and it would only be refreshed when the user session gets destroyed by other means like inactivity, session expiration or logging out and in. This value can be any value including 0, setting it to 0 would automatically refresh the session on every single request. This means Authelia will have to contact the LDAP backend every time an element on a page loads which could be substantially costly. It’s a trade-off between load and security that you should adapt according to your own security policy. ",
    "url": "/docs/configuration/authentication/ldap.html#refresh-interval",
    "relUrl": "/configuration/authentication/ldap.html#refresh-interval"
  },"85": {
    "doc": "LDAP",
    "title": "Important notes",
    "content": "Users must be uniquely identified by an attribute, this attribute must obviously contain a single value and be guaranteed by the administrator to be unique. If multiple users have the same value, Authelia will simply fail authenticating the user and display an error message in the logs. In order to avoid such problems, we highly recommended you follow https://www.ietf.org/rfc/rfc2307.txt by using sAMAccountName for Active Directory and uid for other implementations as the attribute holding the unique identifier for your users. As of versions &gt; 4.24.0 the users_filter must include the username_attribute placeholder, not including this will result in Authelia throwing an error. In versions &lt;= 4.24.0 not including the username_attribute placeholder will cause issues with the session refresh and will result in session resets when the refresh interval has expired, default of 5 minutes. ",
    "url": "/docs/configuration/authentication/ldap.html#important-notes",
    "relUrl": "/configuration/authentication/ldap.html#important-notes"
  },"86": {
    "doc": "LDAP",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/authentication/ldap.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/authentication/ldap.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"87": {
    "doc": "MariaDB",
    "title": "MariaDB",
    "content": "storage: mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: mypassword . ",
    "url": "/docs/configuration/storage/mariadb.html",
    "relUrl": "/configuration/storage/mariadb.html"
  },"88": {
    "doc": "MariaDB",
    "title": "IPv6 Addresses",
    "content": "If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . ",
    "url": "/docs/configuration/storage/mariadb.html#ipv6-addresses",
    "relUrl": "/configuration/storage/mariadb.html#ipv6-addresses"
  },"89": {
    "doc": "MariaDB",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/storage/mariadb.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/storage/mariadb.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"90": {
    "doc": "Security Measures",
    "title": "Security Measures",
    "content": " ",
    "url": "/docs/security/measures.html",
    "relUrl": "/security/measures.html"
  },"91": {
    "doc": "Security Measures",
    "title": "Protection against cookie theft",
    "content": "Authelia uses two mechanisms to protect against cookie theft: . | session attribute httpOnly set to true make client-side code unable to read the cookie. | session attribute secure ensure the cookie will never be sent over an insecure HTTP connections. | . ",
    "url": "/docs/security/measures.html#protection-against-cookie-theft",
    "relUrl": "/security/measures.html#protection-against-cookie-theft"
  },"92": {
    "doc": "Security Measures",
    "title": "Protection against multi-domain cookie attacks",
    "content": "Since Authelia uses multi-domain cookies to perform single sign-on, an attacker who poisoned a user’s DNS cache can easily retrieve the user’s cookies by making the user send a request to one of the attacker’s IPs. To mitigate this risk, it’s advisable to only use HTTPS connections with valid certificates and enforce it with HTTP Strict Transport Security (HSTS) so that the attacker must also require the certificate to retrieve the cookies. Note that using HSTS has consequences. That’s why you should read the blog post nginx has written on HSTS. ",
    "url": "/docs/security/measures.html#protection-against-multi-domain-cookie-attacks",
    "relUrl": "/security/measures.html#protection-against-multi-domain-cookie-attacks"
  },"93": {
    "doc": "Security Measures",
    "title": "Protection against username enumeration",
    "content": "Authelia adaptively delays authentication attempts based on the mean (average) of the previous 10 successful attempts, and a small random interval to make it even harder to determine if the attempt was successful. On start it is assumed that the last 10 attempts took 1000ms, this quickly grows or shrinks to the correct value over time regardless of the authentication backend. The cost of this is low since in the instance of a user not existing it just sleeps to delay the login. Lastly the absolute minimum time authentication can take is 250ms. Both of these measures also have the added effect of creating an additional delay for all authentication attempts reducing the likelihood a password can be brute-forced even if regulation settings are too permissive. ",
    "url": "/docs/security/measures.html#protection-against-username-enumeration",
    "relUrl": "/security/measures.html#protection-against-username-enumeration"
  },"94": {
    "doc": "Security Measures",
    "title": "Protections against password cracking (File authentication provider)",
    "content": "Authelia implements a variety of measures to prevent an attacker cracking passwords if they somehow obtain the file used by the file authentication provider, this is unrelated to LDAP auth. First and foremost Authelia only uses very secure hashing algorithms with sane and secure defaults. The first and default hashing algorithm we use is Argon2id which is currently considered the most secure hashing algorithm. We also support SHA512, which previously was the default. Secondly Authelia uses salting with all hashing algorithms. These salts are generated with a random string generator, which is seeded every time it’s used by a cryptographically secure 1024bit prime number. This ensures that even if an attacker obtains the file, each password has to be brute forced individually. Lastly Authelia’s implementation of Argon2id is highly tunable. You can tune the key length, salt used, iterations (time), parallelism, and memory usage. To read more about this please read how to configure file authentication. ",
    "url": "/docs/security/measures.html#protections-against-password-cracking-file-authentication-provider",
    "relUrl": "/security/measures.html#protections-against-password-cracking-file-authentication-provider"
  },"95": {
    "doc": "Security Measures",
    "title": "User profile and group membership always kept up-to-date (LDAP authentication provider)",
    "content": "Authelia by default refreshes the user’s profile and membership every 5 minutes. Additionally, it will invalidate any session where the user could not be retrieved from LDAP based on the user filter, for example if they were deleted or disabled provided the user filter is set correctly. These updates occur when a user accesses a resource protected by Authelia. These protections can be tuned according to your security policy by changing refresh_interval, however we believe that 5 minutes is a fairly safe interval. ",
    "url": "/docs/security/measures.html#user-profile-and-group-membership-always-kept-up-to-date-ldap-authentication-provider",
    "relUrl": "/security/measures.html#user-profile-and-group-membership-always-kept-up-to-date-ldap-authentication-provider"
  },"96": {
    "doc": "Security Measures",
    "title": "Notifier security measures (SMTP)",
    "content": "By default the SMTP Notifier implementation does not allow connections that are not secure. As such all connections require the following: . | TLS Connection (STARTTLS or SMTPS) has been negotiated before authentication or sending emails (unauthenticated connections require it as well) | Valid X509 Certificate presented to the client during the TLS handshake | . There is an option to disable both of these security measures however they are not recommended. You should only do this in a situation where you control all networks between Authelia and the SMTP server. The following configuration options exist to configure the security level: . SMTPS vs STARTTLS . By default all connections start as plain text and are upgraded via STARTTLS. SMTPS is supported, however due to the fact it was basically considered deprecated before the turn of the century, there is no way to configure it. It happens automatically when a SMTP notifier is configured with the SMTPS port of 465. Configuration Option: disable_verify_cert . This is a YAML boolean type (true/false, y/n, 1/0, etc). This disables the X509 PKI verification mechanism. We recommend using the trusted_cert option over this, as disabling this security feature makes you vulnerable to MITM attacks. Configuration Option: disable_require_tls . This is a YAML boolean type (true/false, y/n, 1/0, etc). This disables the requirement that all connections must be over TLS. This is only usable currently with authentication disabled (comment the password) and as such is only an option for SMTP servers that allow unauthenticated relay (bad practice). Configuration Option: trusted_cert . This is a YAML string type. This specifies the file location of a pub certificate that can be used to validate the authenticity of a server with a self signed certificate. This can either be the public cert of the certificate authority used to sign the certificate or the public key itself. They must be in the PEM format. The certificate is added in addition to the certificates trusted by the host machine. If the certificate is invalid, inaccessible, or is otherwise not configured; Authelia just uses the hosts certificates. Explanation . There are a few reasons for the security measures implemented: . | Transmitting username’s and passwords over plain-text is an obvious vulnerability | The emails generated by Authelia, if transmitted in plain-text could allow an attacker to intercept a link used to setup 2FA; which reduces security | Not validating the identity of the server allows man-in-the-middle attacks | . ",
    "url": "/docs/security/measures.html#notifier-security-measures-smtp",
    "relUrl": "/security/measures.html#notifier-security-measures-smtp"
  },"97": {
    "doc": "Security Measures",
    "title": "Additional security",
    "content": "Reset Password . It’s possible to disable the reset password functionality and is recommended for anyone wanting to increase security. See the configuration for information. Session security . We have a few options to configure the security of a session. The main and most important one is the session secret. This is used to encrypt the session data when when stored in the Redis key value database. This should be as random as possible. Additionally you can configure the validity period of sessions. For example in a highly security conscious domain you would probably want to set the session remember_me_duration to 0 to disable this feature, and set an expiration of something like 2 hours and inactivity of 10 minutes. This means the hard limit or the time the session will be destroyed no matter what is 2 hours, and the soft limit or the time a user can be inactive for is 10 minutes. Additional proxy protection measures . You can also apply the following headers to your proxy configuration for improving security. Please read the documentation of those headers before applying them blindly. nginx . # We don't want any credentials / TOTP secret key / QR code to be cached by # the client add_header Cache-Control \"no-store\"; add_header Pragma \"no-cache\"; # Clickjacking / XSS protection # We don't want Authelia's login page to be rendered within a &lt;frame&gt;, # &lt;iframe&gt; or &lt;object&gt; from an external website. add_header X-Frame-Options \"SAMEORIGIN\"; # Block pages from loading when they detect reflected XSS attacks. add_header X-XSS-Protection \"1; mode=block\"; . Traefik 2.x - Kubernetes CRD . --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: headers-authelia spec: headers: browserXssFilter: true customFrameOptionsValue: \"SAMEORIGIN\" customResponseHeaders: Cache-Control: \"no-store\" Pragma: \"no-cache\" --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: authelia spec: entryPoints: - http routes: - match: Host(`auth.example.com`) &amp;&amp; PathPrefix(`/`) kind: Rule priority: 1 middlewares: - name: headers-authelia namespace: authelia services: - name: authelia port: 80 . Traefik 2.x - docker-compose . services: authelia: labels: - \"traefik.http.routers.authelia.middlewares=authelia-headers\" - \"traefik.http.middlewares.authelia-headers.headers.browserXssFilter=true\" - \"traefik.http.middlewares.authelia-headers.headers.customFrameOptionsValue=SAMEORIGIN\" - \"traefik.http.middlewares.authelia-headers.headers.customResponseHeaders.Cache-Control=no-store\" - \"traefik.http.middlewares.authelia-headers.headers.customResponseHeaders.Pragma=no-cache\" . More protections measures with fail2ban . If you are running fail2ban, adding a filter and jail for Authelia can reduce load on the application / web server. Fail2ban will ban IPs exceeding a threshold of repeated failed logins at the firewall level of your host. If you are using Docker, the Authelia log file location has to be mounted from the host system to the container for fail2ban to access it. Create a configuration file in the filter.d folder with the content below. In Debian-based systems the folder is typically located at /etc/fail2ban/filter.d. # Fail2Ban filter for Authelia # Make sure that the HTTP header \"X-Forwarded-For\" received by Authelia's backend # only contains a single IP address (the one from the end-user), and not the proxy chain # (it is misleading: usually, this is the purpose of this header). # the failregex rule counts every failed login (wrong username or password) and failed TOTP entry as a failure # the ignoreregex rule ignores debug, info and warning messages as all authentication failures are flagged as level=error by Authelia [Definition] failregex = ^.*Error while checking password for.*remote_ip=&lt;HOST&gt; stack.* ^.*Credentials are wrong for user .*remote_ip=&lt;HOST&gt; stack.* ^.*Wrong passcode during TOTP validation.*remote_ip=&lt;HOST&gt; stack.* ignoreregex = ^.*level=debug.* ^.*level=info.* ^.*level=warning.* . Modify the jail.local file. In Debian-based systems the folder is typically located at /etc/fail2ban/. If the file does not exist, create it by copying the jail.conf cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local. Add an Authelia entry to the “Jails” section of the file: . [authelia] enabled = true port = http,https,9091 filter = authelia logpath = /path-to-your-authelia.log maxretry = 3 bantime = 1d findtime = 1d chain = DOCKER-USER . If you are not using Docker remove the the line “chain = DOCKER-USER” . Finally, restart the fail2ban service. ",
    "url": "/docs/security/measures.html#additional-security",
    "relUrl": "/security/measures.html#additional-security"
  },"98": {
    "doc": "Security Measures",
    "title": "Container privilege de-escalation",
    "content": "Authelia will run as root by default, there are two options to run as a non-root user. The first option is to use the Docker --user option on the command line or in docker-compose. The second option is to use the PUID and PGID environment variables. An added benefit of using the environment variables is the mounted volumes ownership will automatically be changed for you. Docker user option . With the Docker --user option, Docker will ensure Authelia is running as the user id and group id you specify. In order to use this option, you will need to mount the /config volume to a directory on the host and set the owner and group of that directory to the same user you supplied to docker. Running Authelia with --user without mounting a volume to /config or incorrectly setting the host systems directory owner will cause Authelia to exit immediately. The docker --user option will take precedence over the environment variables. On the command line, you would create your Authelia data directory, change ownership to your non-root user and run Authelia with --user set: . mkdir /authelia chown user:group /authelia docker run --user user:group -v /authelia:/config authelia/authelia:latest . As a docker-compose.yml file: . version: '3.8' services: authelia: image: authelia/authelia container_name: authelia user: 1000:1000 volumes: - ./authelia:/config . PUID/PGID environment variables . If you choose to use the environment variables, the correct ownership will be applied automatically on startup of the container, so there’s no need to chown before running, to use this on the command line use the following: . docker run -e PUID=1000 -e PGID=1000 -v /authelia:/config authelia:authelia:latest . As a docker-compose.yml file: . version: '3.8' services: authelia: image: authelia/authelia container_name: authelia environment: PUID: 1000 PGID: 1000 volumes: - ./authelia:/config . ",
    "url": "/docs/security/measures.html#container-privilege-de-escalation",
    "relUrl": "/security/measures.html#container-privilege-de-escalation"
  },"99": {
    "doc": "Miscellaneous",
    "title": "Miscellaneous",
    "content": "Here are the main customizable options in Authelia. ",
    "url": "/docs/configuration/miscellaneous.html",
    "relUrl": "/configuration/miscellaneous.html"
  },"100": {
    "doc": "Miscellaneous",
    "title": "Host &amp; Port",
    "content": "optional: true . Defines the address and port to listen on. host: 0.0.0.0 port: 9091 . Note: If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . ",
    "url": "/docs/configuration/miscellaneous.html#host--port",
    "relUrl": "/configuration/miscellaneous.html#host--port"
  },"101": {
    "doc": "Miscellaneous",
    "title": "TLS",
    "content": "optional: true . Authelia can use TLS. Provide the certificate and the key with the following configuration options: . tls_key: /config/ssl/key.pem tls_cert: /config/ssl/cert.pem . ",
    "url": "/docs/configuration/miscellaneous.html#tls",
    "relUrl": "/configuration/miscellaneous.html#tls"
  },"102": {
    "doc": "Miscellaneous",
    "title": "Certificates Directory",
    "content": "optional: true . This option defines the location of additional certificates to load into the trust chain specifically for Authelia. This currently affects both the SMTP notifier and the LDAP authentication backend. The certificates should all be in the PEM format and end with the extension .pem, .crt, or .cer. You can either add the individual certificates public key or the CA public key which signed them (don’t add the private key). ",
    "url": "/docs/configuration/miscellaneous.html#certificates-directory",
    "relUrl": "/configuration/miscellaneous.html#certificates-directory"
  },"103": {
    "doc": "Miscellaneous",
    "title": "Log",
    "content": "Log level . optional: true . Defines the level of logs used by Authelia. This level can be set to trace, debug or info. When setting log_level to trace, you will generate a large amount of log entries and expose the /debug/vars and /debug/pprof/ endpoints which should not be enabled in production. log_level: debug . Log format . optional: true . Defines the format of the logs written by Authelia. This format can be set to json or text. log_format: json . JSON format . {\"level\":\"info\",\"msg\":\"Logging severity set to info\",\"time\":\"2020-01-01T00:00:00+11:00\"} {\"level\":\"info\",\"msg\":\"Authelia is listening for non-TLS connections on 0.0.0.0:9091\",\"time\":\"2020-01-01T00:00:00+11:00\"} . Text format . time=\"2020-01-01T00:00:00+11:00\" level=info msg=\"Logging severity set to info\" time=\"2020-01-01T00:00:00+11:00\" level=info msg=\"Authelia is listening for non-TLS connections on 0.0.0.0:9091\" . Log file path . optional: true . Logs can be stored in a file when file path is provided. Otherwise logs are written to standard output. When setting the log_level to debug or trace this will generate large amount of log entries. Administrators will need to ensure that they rotate and/or truncate the logs over time to prevent significant long-term disk usage. log_file_path: /config/authelia.log . ",
    "url": "/docs/configuration/miscellaneous.html#log",
    "relUrl": "/configuration/miscellaneous.html#log"
  },"104": {
    "doc": "Miscellaneous",
    "title": "JWT Secret",
    "content": "optional: false . Defines the secret used to craft JWT tokens leveraged by the identity verification process. This can also be defined using a secret. jwt_secret: v3ry_important_s3cr3t . ",
    "url": "/docs/configuration/miscellaneous.html#jwt-secret",
    "relUrl": "/configuration/miscellaneous.html#jwt-secret"
  },"105": {
    "doc": "Miscellaneous",
    "title": "Default redirection URL",
    "content": "optional: true . The default redirection URL is the URL where users are redirected when Authelia cannot detect the target URL where the user was heading. In a normal authentication workflow, a user tries to access a website and she gets redirected to the sign-in portal in order to authenticate. Since the user initially targeted a website, the portal knows where the user was heading and can redirect her after the authentication process. However, when a user visits the sign in portal directly, the portal considers the targeted website is the portal. In that case and if the default redirection URL is configured, the user is redirected to that URL. If not defined, the user is not redirected after authentication. ",
    "url": "/docs/configuration/miscellaneous.html#default-redirection-url",
    "relUrl": "/configuration/miscellaneous.html#default-redirection-url"
  },"106": {
    "doc": "MySQL",
    "title": "MySQL",
    "content": "storage: mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: mypassword . ",
    "url": "/docs/configuration/storage/mysql.html",
    "relUrl": "/configuration/storage/mysql.html"
  },"107": {
    "doc": "MySQL",
    "title": "IPv6 Addresses",
    "content": "If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . ",
    "url": "/docs/configuration/storage/mysql.html#ipv6-addresses",
    "relUrl": "/configuration/storage/mysql.html#ipv6-addresses"
  },"108": {
    "doc": "MySQL",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/storage/mysql.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/storage/mysql.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"109": {
    "doc": "Nginx",
    "title": "Nginx",
    "content": "nginx is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/nginx.html",
    "relUrl": "/deployment/supported-proxies/nginx.html"
  },"110": {
    "doc": "Nginx",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Authelia portal | Protected endpoint (Nextcloud) | Supplementary config | . With the below configuration you can add authelia.conf to virtual hosts to support protection with Authelia. auth.conf is utilised to enable the protection either at the root location or a more specific location/route. proxy.conf is included just for completeness. Supplementary config . authelia.conf . set $upstream_authelia http://authelia:9091/api/verify; # Virtual endpoint created by nginx to forward auth requests. location /authelia { internal; proxy_pass_request_body off; proxy_pass $upstream_authelia; proxy_set_header Content-Length \"\"; # Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # [REQUIRED] Needed by Authelia to check authorizations of the resource. # Provide either X-Original-URL and X-Forwarded-Proto or # X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-Uri or both. # Those headers will be used by Authelia to deduce the target url of the user. # Basic Proxy Config client_body_buffer_size 128k; proxy_set_header Host $host; proxy_set_header X-Original-URL $scheme://$http_host$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Method $request_method; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 4 32k; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 240; proxy_send_timeout 240; proxy_connect_timeout 240; } . auth.conf . # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it's gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; auth_request_set $name $upstream_http_remote_name; auth_request_set $email $upstream_http_remote_email; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; proxy_set_header Remote-Name $name; proxy_set_header Remote-Email $email; # If Authelia returns 401, then nginx redirects the user to the login portal. # If it returns 200, then the request pass through to the backend. # For other type of errors, nginx will handle them as usual. error_page 401 =302 https://auth.example.com/?rd=$target_url; . proxy.conf . client_body_buffer_size 128k; #Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 360; proxy_send_timeout 360; proxy_connect_timeout 360; # Basic Proxy Config proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 64 256k; # If behind reverse proxy, forwards the correct IP set_real_ip_from 10.0.0.0/8; set_real_ip_from 172.16.0.0/12; set_real_ip_from 192.168.0.0/16; set_real_ip_from fc00::/7; real_ip_header X-Forwarded-For; real_ip_recursive on; . Authelia Portal . server { server_name auth.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name auth.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; location / { set $upstream_authelia http://authelia:9091; # This example assumes a Docker deployment proxy_pass $upstream_authelia; include /config/nginx/proxy.conf; } } . Protected Endpoint . server { server_name nextcloud.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name nextcloud.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; include /config/nginx/authelia.conf; # Virtual endpoint to forward auth requests location / { set $upstream_nextcloud https://nextcloud; proxy_pass $upstream_nextcloud; include /config/nginx/auth.conf; # Activates Authelia for specified route/location, please ensure you have setup the domain in your configuration.yml include /config/nginx/proxy.conf; # Reverse proxy configuration } } . Basic Auth Example . Here’s an example for using HTTP basic auth on a specific endpoint. It is based on the full example above. authelia-basic.conf . # Notice we added the auth=basic query arg here set $upstream_authelia http://authelia:9091/api/verify?auth=basic; location /authelia { internal; proxy_pass_request_body off; proxy_pass $upstream_authelia; proxy_set_header Content-Length \"\"; # Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # [REQUIRED] Needed by Authelia to check authorizations of the resource. # Provide either X-Original-URL and X-Forwarded-Proto or # X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-Uri or both. # Those headers will be used by Authelia to deduce the target url of the user. # Basic Proxy Config client_body_buffer_size 128k; proxy_set_header Host $host; proxy_set_header X-Original-URL $scheme://$http_host$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Method $request_method; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 4 32k; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 240; proxy_send_timeout 240; proxy_connect_timeout 240; } . auth-basic.conf . Same as auth.conf but without the error_page directive. We want nginx to proxy the 401 back to the client, not to return a 301. # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it's gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; auth_request_set $name $upstream_http_remote_name; auth_request_set $email $upstream_http_remote_email; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; proxy_set_header Remote-Name $name; proxy_set_header Remote-Email $email; # If Authelia returns 401, then nginx passes it to the user. # If it returns 200, then the request pass through to the backend. Protected Endpoint . server { server_name nextcloud.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name nextcloud.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; include /config/nginx/authelia-basic.conf; # Use the \"basic\" endpoint location / { set $upstream_nextcloud https://nextcloud; proxy_pass $upstream_nextcloud; include /config/nginx/auth-basic.conf; # Activate authelia with basic auth include /config/nginx/proxy.conf; # this file is the exact same as above } } . Basic auth for specific client . If you’d like to force basic auth for some requests, you can use the following template: . authelia-detect.conf . set $is_basic_auth \"\"; # false value set $upstream_authelia http://authelia:9091/api/verify; # Detect the client you want to force basic auth for here # For the example we just match a path on the original request if ($request_uri = \"/force-basic\") { set $is_basic_auth \"true\"; set $upstream_authelia \"$upstream_authelia?auth=basic\"; } location = /authelia { # Same as above } # A new virtual endpoint to used if the auth_request failed location = /authelia-redirect { internal; if ($is_basic_auth) { # This is a request where we decided to use basic auth, return a 401. # Nginx will also proxy back the WWW-Authenticate header from Authelia's # response. This is what informs the client we're expecting basic auth. return 401; } # The original request didn't target /force-basic, redirect to the pretty login page # This is what `error_page 401 =302 https://auth.example.com/?rd=$target_url;` did. return 302 https://auth.example.com/$is_args$args; } . auth.conf . Here we replace error_page directive to determine if basic auth should be utilised or not. # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it's gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; auth_request_set $name $upstream_http_remote_name; auth_request_set $email $upstream_http_remote_email; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; proxy_set_header Remote-Name $name; proxy_set_header Remote-Email $email; # If Authelia returns 401, then nginx passes it to the user. # If it returns 200, then the request pass through to the backend. error_page 401 /authelia-redirect?rd=$target_url; . This tells nginx to use the virtual endpoint we defined above in case the auth_request failed. ",
    "url": "/docs/deployment/supported-proxies/nginx.html#configuration",
    "relUrl": "/deployment/supported-proxies/nginx.html#configuration"
  },"111": {
    "doc": "Time-based One-Time Password",
    "title": "Time-based One-Time Password",
    "content": "Authelia supports Time-base one-time password generated by apps like Google Authenticator. After having successfully completed the first factor, select One-Time Password method option and click on Not registered yet? link. This will e-mail you to confirm your identity. NOTE: If you’re testing Authelia, this e-mail has likely been sent to the mailbox available at https://mail.example.com:8080/ . Once this validation step is completed, a QR Code gets displayed. You can then use Google Authenticator to scan the code in order to register your device. From now on, you get tokens generated every 30 seconds that you can use to validate the second factor in Authelia. ",
    "url": "/docs/features/2fa/one-time-password.html",
    "relUrl": "/features/2fa/one-time-password.html"
  },"112": {
    "doc": "Time-based One-Time Password",
    "title": "Limitations",
    "content": "Users currently can only enroll a single TOTP device in Authelia. Multiple single type device enrollment will be available when this issue has been resolved. ",
    "url": "/docs/features/2fa/one-time-password.html#limitations",
    "relUrl": "/features/2fa/one-time-password.html#limitations"
  },"113": {
    "doc": "Time-based One-Time Password",
    "title": "Time-based One-Time Password",
    "content": "Authelia uses time based one-time passwords as the OTP method. You have the option to tune the settings of the TOTP generation, and you can see a full example of TOTP configuration below, as well as sections describing them. totp: issuer: authelia.com period: 30 skew: 1 . ",
    "url": "/docs/configuration/one-time-password.html",
    "relUrl": "/configuration/one-time-password.html"
  },"114": {
    "doc": "Time-based One-Time Password",
    "title": "Issuer",
    "content": "Applications generating one-time passwords usually display an issuer to differentiate applications registered by the user. Authelia allows customisation of the issuer to differentiate the entry created by Authelia from others. ",
    "url": "/docs/configuration/one-time-password.html#issuer",
    "relUrl": "/configuration/one-time-password.html#issuer"
  },"115": {
    "doc": "Time-based One-Time Password",
    "title": "Period and Skew",
    "content": "The period and skew configuration parameters affect each other. The default values are a period of 30 and a skew of 1. It is highly recommended you do not change these unless you wish to set skew to 0. The way you configure these affects security by changing the length of time a one-time password is valid for. The formula to calculate the effective validity period is period + (period * skew * 2). For example period 30 and skew 1 would result in 90 seconds of validity, and period 30 and skew 2 would result in 150 seconds of validity. Period . Configures the period of time in seconds a one-time password is current for. It is important to note that changing this value will require your users to register their application again. It is recommended to keep this value set to 30, the minimum is 1. Skew . Configures the number of one-time passwords either side of the current one that are considered valid, each time you increase this it makes two more one-time passwords valid. For example the default of 1 has a total of 3 keys valid. A value of 2 has 5 one-time passwords valid. It is recommended to keep this value set to 0 or 1, the minimum is 0. ",
    "url": "/docs/configuration/one-time-password.html#period-and-skew",
    "relUrl": "/configuration/one-time-password.html#period-and-skew"
  },"116": {
    "doc": "Password Reset",
    "title": "Password Reset",
    "content": "Authelia provides a workflow to let users reset their password when they lose it. To disable reset password functionality please see the configuration docs. A simple click on Reset password? for starting the process. Note that resetting a password requires a new identity verification using the e-mail of the user. Give your username and receive an e-mail to verify your identity. Once your identity has been verified, fill in the form to reset your password. Now you can authenticate with your new credentials. ",
    "url": "/docs/features/password-reset.html",
    "relUrl": "/features/password-reset.html"
  },"117": {
    "doc": "PostgreSQL",
    "title": "PostgreSQL",
    "content": "storage: postgres: host: 127.0.0.1 port: 5432 database: authelia username: authelia # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: mypassword sslmode: disable . ",
    "url": "/docs/configuration/storage/postgres.html",
    "relUrl": "/configuration/storage/postgres.html"
  },"118": {
    "doc": "PostgreSQL",
    "title": "IPv6 Addresses",
    "content": "If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . ",
    "url": "/docs/configuration/storage/postgres.html#ipv6-addresses",
    "relUrl": "/configuration/storage/postgres.html#ipv6-addresses"
  },"119": {
    "doc": "PostgreSQL",
    "title": "SSL Mode",
    "content": "SSL mode configures how to handle SSL connections with Postgres. Valid options are ‘disable’, ‘require’, ‘verify-ca’, or ‘verify-full’. See the PostgreSQL Documentation or pgx - PostgreSQL Driver and Toolkit Documentation for more information. ",
    "url": "/docs/configuration/storage/postgres.html#ssl-mode",
    "relUrl": "/configuration/storage/postgres.html#ssl-mode"
  },"120": {
    "doc": "PostgreSQL",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/storage/postgres.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/storage/postgres.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"121": {
    "doc": "Push Notification",
    "title": "Mobile Push Notification",
    "content": "Mobile push notifications is the new trendy second factor method. When second factor is requested by Authelia, a notification is sent on your phone that you can either accept or deny. Authelia leverages Duo third party to provide this feature. First, sign up on their website, log in, create a user account and attach it a mobile device. Beware that the name of the user must match the name of the user in Authelia. Then, in Duo interface, click on Applications and Protect an Application. Select the option Partner Auth API. This will generate an integration key, a secret key and a hostname. You can set the name of the application to Authelia and then you must add the generated information to Authelia configuration as shown below: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . Now that Authelia is configured, pass the first factor and select the Push notification option. You should now receive a notification on your mobile phone with all the details about the authentication request. ",
    "url": "/docs/features/2fa/push-notifications.html#mobile-push-notification",
    "relUrl": "/features/2fa/push-notifications.html#mobile-push-notification"
  },"122": {
    "doc": "Push Notification",
    "title": "Limitation",
    "content": "Users must be enrolled via the Duo Admin panel, they cannot enroll a device from Authelia yet. ",
    "url": "/docs/features/2fa/push-notifications.html#limitation",
    "relUrl": "/features/2fa/push-notifications.html#limitation"
  },"123": {
    "doc": "Push Notification",
    "title": "FAQ",
    "content": "Why don’t I have access to the Push Notification option? . It’s likely that you have not configured Authelia correctly. Please read this documentation again and be sure you had a look at config.template.yml. ",
    "url": "/docs/features/2fa/push-notifications.html#faq",
    "relUrl": "/features/2fa/push-notifications.html#faq"
  },"124": {
    "doc": "Push Notification",
    "title": "Push Notification",
    "content": " ",
    "url": "/docs/features/2fa/push-notifications.html",
    "relUrl": "/features/2fa/push-notifications.html"
  },"125": {
    "doc": "Regulation",
    "title": "Regulation",
    "content": "Authelia can temporarily ban accounts when there are too many authentication attempts. This helps prevent brute-force attacks. ",
    "url": "/docs/configuration/regulation.html",
    "relUrl": "/configuration/regulation.html"
  },"126": {
    "doc": "Regulation",
    "title": "Configuration",
    "content": "regulation: # The number of failed login attempts before user is banned. # Set it to 0 to disable regulation. max_retries: 3 # The time range during which the user can attempt login before being banned. # The user is banned if the authentication failed `max_retries` times in a `find_time` seconds window. # Find Time accepts duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format find_time: 2m # The length of time before a banned user can sign in again. # Find Time accepts duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format ban_time: 5m . Duration Notation . The configuration parameters find_time, and ban_time use duration notation. See the documentation for duration notation format for more information. ",
    "url": "/docs/configuration/regulation.html#configuration",
    "relUrl": "/configuration/regulation.html#configuration"
  },"127": {
    "doc": "Regulation",
    "title": "Regulation",
    "content": "Authelia takes the security of users very seriously and comes with a way to avoid brute-forcing the first factor credentials by regulating the authentication attempts and temporarily banning an account when too many attempts have been made. ",
    "url": "/docs/features/regulation.html",
    "relUrl": "/features/regulation.html"
  },"128": {
    "doc": "Regulation",
    "title": "Configuration",
    "content": "Please check the dedicated documentation. ",
    "url": "/docs/features/regulation.html#configuration",
    "relUrl": "/features/regulation.html#configuration"
  },"129": {
    "doc": "Roadmap",
    "title": "Roadmap",
    "content": "Currently the team consists of 3 globally distributed developers working actively on improving Authelia in our spare time and we define our priorities based on a roadmap that we share here for transparency. We also try to balance features and improvements as much as possible with the maintenance tasks we have to perform to keep the backlog of open issues in a reasonable state. If you’re willing to contribute and help us move forward faster, get in touch with us on Matrix. We’ll be glad to share ideas and plans with you. Below are the prioritised roadmap items: . | Authelia acts as an OpenID Connect Provider. This is a high priority because currently the only way to pass authentication information back to the protected app is through the use of HTTP headers as described here however, many apps either do not support this method or are starting to move away from this in favour of OpenID Connect or OAuth2 internally or via plugins. | Administration interface. This is useful in many cases to properly manage users and administrate activities like unbanning banned users. In the future we can even think of adding/removing users from there, request a password reset for a user or all users, request a 2FA enrollment, temporarily block users, etc… . | User interface. This will help the users manage their 2FA devices, reset their password, review their authentication activity. In the future we envisage users will be able to customize their profile with an avatar, set their preferences regarding 2FA and according to the global policy defined by administrators, etc… . | Facilitate setup on Kubernetes. There are mainly two objectives here. First, we need to provide the documentation required to setup Authelia on Kubernetes. Even though, some users already have it working and the feature is even tested in the project, there is a clear lack of documentation. The second item is to provide a Helm chart to streamline the setup on Kubernetes. | . ",
    "url": "/docs/roadmap.html",
    "relUrl": "/roadmap.html"
  },"130": {
    "doc": "Secrets",
    "title": "Secrets",
    "content": "Configuration of Authelia requires some secrets and passwords. Even if they can be set in the configuration file, the recommended way to set secrets is to use environment variables as described below. ",
    "url": "/docs/configuration/secrets.html",
    "relUrl": "/configuration/secrets.html"
  },"131": {
    "doc": "Secrets",
    "title": "Environment variables",
    "content": "A secret can be configured using an environment variable with the prefix AUTHELIA_ followed by the path of the option capitalized and with dots replaced by underscores followed by the suffix _FILE. The contents of the environment variable must be a path to a file containing the secret data. This file must be readable by the user the Authelia daemon is running as. For instance the LDAP password can be defined in the configuration at the path authentication_backend.ldap.password, so this password could alternatively be set using the environment variable called AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE. Here is the list of the environment variables which are considered secrets and can be defined. Any other option defined using an environment variable will not be replaced. | Configuration Key | Environment Variable | . | jwt_secret | AUTHELIA_JWT_SECRET_FILE | . | duo_api.secret_key | AUTHELIA_DUO_API_SECRET_KEY_FILE | . | session.secret | AUTHELIA_SESSION_SECRET_FILE | . | session.redis.password | AUTHELIA_SESSION_REDIS_PASSWORD_FILE | . | session.redis.high_availability.sentinel_password | AUTHELIA_REDIS_HIGH_AVAILABILITY_SENTINEL_PASSWORD | . | storage.mysql.password | AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE | . | storage.postgres.password | AUTHELIA_STORAGE_POSTGRES_PASSWORD_FILE | . | notifier.smtp.password | AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE | . | authentication_backend.ldap.password | AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE | . ",
    "url": "/docs/configuration/secrets.html#environment-variables",
    "relUrl": "/configuration/secrets.html#environment-variables"
  },"132": {
    "doc": "Secrets",
    "title": "Secrets in configuration file",
    "content": "If for some reason you prefer keeping the secrets in the configuration file, be sure to apply the right permissions to the file in order to prevent secret leaks if an another application gets compromised on your server. The UNIX permissions should probably be something like 600. ",
    "url": "/docs/configuration/secrets.html#secrets-in-configuration-file",
    "relUrl": "/configuration/secrets.html#secrets-in-configuration-file"
  },"133": {
    "doc": "Secrets",
    "title": "Secrets exposed in an environment variable",
    "content": "DEPRECATION NOTICE: This backwards compatibility feature has been removed in 4.18.0+. Prior to implementing file secrets you were able to define the values of secrets in the environment variables themselves in plain text instead of referencing a file. This is no longer available as an option, please see the table above for the file based replacements. See this article for reasons why this was removed. ",
    "url": "/docs/configuration/secrets.html#secrets-exposed-in-an-environment-variable",
    "relUrl": "/configuration/secrets.html#secrets-exposed-in-an-environment-variable"
  },"134": {
    "doc": "Secrets",
    "title": "Docker",
    "content": "Secrets can be provided in a docker-compose.yml either with Docker secrets or bind mounted secret files, examples of these are provided below. Compose with Docker secrets . This example assumes secrets are stored in /path/to/authelia/secrets/{secretname} on the host and are exposed with Docker secrets in a docker-compose.yml file: . version: '3.8' networks: net: driver: bridge secrets: jwt: file: /path/to/authelia/secrets/jwt duo: file: /path/to/authelia/secrets/duo session: file: /path/to/authelia/secrets/session redis: file: /path/to/authelia/secrets/redis mysql: file: /path/to/authelia/secrets/mysql smtp: file: /path/to/authelia/secrets/smtp ldap: file: /path/to/authelia/secrets/ldap services: authelia: image: authelia/authelia container_name: authelia secrets: - jwt - duo - session - redis - mysql - smtp - ldap volumes: - /path/to/authelia:/config networks: - net expose: - 9091 restart: unless-stopped environment: - AUTHELIA_JWT_SECRET_FILE=/run/secrets/jwt - AUTHELIA_DUO_API_SECRET_KEY_FILE=/run/secrets/duo - AUTHELIA_SESSION_SECRET_FILE=/run/secrets/session - AUTHELIA_SESSION_REDIS_PASSWORD_FILE=/run/secrets/redis - AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE=/run/secrets/mysql - AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE=/run/secrets/smtp - AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE=/run/secrets/ldap - TZ=Australia/Melbourne . Compose with bind mounted secret files . This example assumes secrets are stored in /path/to/authelia/secrets/{secretname} on the host and are exposed with bind mounted secret files in a docker-compose.yml file at /config/secrets/: . version: '3.8' networks: net: driver: bridge services: authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/config networks: - net expose: - 9091 restart: unless-stopped environment: - AUTHELIA_JWT_SECRET_FILE=/config/secrets/jwt - AUTHELIA_DUO_API_SECRET_KEY_FILE=/config/secrets/duo - AUTHELIA_SESSION_SECRET_FILE=/config/secrets/session - AUTHELIA_SESSION_REDIS_PASSWORD_FILE=/config/secrets/redis - AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE=/config/secrets/mysql - AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE=/config/secrets/smtp - AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE=/config/secrets/ldap - TZ=Australia/Melbourne . ",
    "url": "/docs/configuration/secrets.html#docker",
    "relUrl": "/configuration/secrets.html#docker"
  },"135": {
    "doc": "Secrets",
    "title": "Kubernetes",
    "content": "Secrets can be mounted as files using the following sample manifests. Kustomization . | Filename: ./kustomization.yaml | Command: kubectl apply -k | Notes: this kustomization expects the Authelia configuration.yml in the same directory. You will need to edit the kustomization.yaml with your desired secrets after the equal signs. If you change the value before the equal sign you’ll have to adjust the volumes section of the daemonset template (or deployment template if you’re using it). | . #filename: ./kustomization.yaml generatorOptions: disableNameSuffixHash: true labels: type: generated app: authelia configMapGenerator: - name: authelia files: - configuration.yml secretGenerator: - name: authelia literals: - jwt_secret=myverysecuresecret - session_secret=mysessionsecret - redis_password=myredispassword - sql_password=mysqlpassword - ldap_password=myldappassword - duo_secret=myduosecretkey - smtp_password=mysmtppassword . DaemonSet . | Filename: ./daemonset.yaml | Command: kubectl apply -f ./daemonset.yaml | Notes: assumes Kubernetes API 1.16 or greater #filename: daemonset.yaml #command: kubectl apply -f daemonset.yaml #notes: assumes kubernetes api 1.16+ apiVersion: apps/v1 kind: DaemonSet metadata: name: authelia namespace: authelia labels: app: authelia spec: selector: matchLabels: app: authelia updateStrategy: type: RollingUpdate template: metadata: labels: app: authelia spec: containers: - name: authelia image: authelia/authelia:latest imagePullPolicy: IfNotPresent env: - name: AUTHELIA_JWT_SECRET_FILE value: /app/secrets/jwt - name: AUTHELIA_DUO_API_SECRET_KEY_FILE value: /app/secrets/duo - name: AUTHELIA_SESSION_SECRET_FILE value: /app/secrets/session - name: AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE value: /app/secrets/ldap_password - name: AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE value: /app/secrets/smtp_password - name: AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE value: /app/secrets/sql_password - name: AUTHELIA_SESSION_REDIS_PASSWORD_FILE value: /app/secrets/redis_password - name: TZ value: America/Toronto ports: - name: authelia-port containerPort: 9091 startupProbe: httpGet: path: /api/state port: authelia-port initialDelaySeconds: 15 timeoutSeconds: 5 periodSeconds: 5 failureThreshold: 4 livenessProbe: httpGet: path: /api/state port: authelia-port initialDelaySeconds: 60 timeoutSeconds: 5 periodSeconds: 30 failureThreshold: 2 readinessProbe: httpGet: path: /api/state port: authelia-port initialDelaySeconds: 15 timeoutSeconds: 5 periodSeconds: 5 failureThreshold: 5 volumeMounts: - mountPath: /config name: config-volume - mountPath: /app/secrets name: secrets readOnly: true volumes: - name: config-volume configMap: name: authelia items: - key: configuration.yml path: configuration.yml - name: secrets secret: secretName: authelia items: - key: jwt_secret path: jwt - key: duo_secret path: duo - key: session_secret path: session - key: redis_password path: redis_password - key: sql_password path: sql_password - key: ldap_password path: ldap_password - key: smtp_password path: smtp_password . | . ",
    "url": "/docs/configuration/secrets.html#kubernetes",
    "relUrl": "/configuration/secrets.html#kubernetes"
  },"136": {
    "doc": "Security Keys",
    "title": "Security Keys",
    "content": "Authelia supports hardware-based second factors leveraging security keys like Yubikeys. Security keys are among the most secure second factor. This method is already supported by many major applications and platforms like Google, Facebook, Github, some banks, and much more… . Normally, the protocol requires your security key to be enrolled on each site before being able to authenticate with it. Since Authelia provides Single Sign-On, your users will need to enroll their device only once to get access to all your applications. After having successfully passed the first factor, select Security Key method and click on Not registered yet? link. This will send you an email to verify your identity. NOTE: This e-mail has likely been sent to the mailbox at https://mail.example.com:8080/ if you’re testing Authelia. Confirm your identity by clicking on Register and you’ll be asked to touch the token of your security key to complete the enrollment. Upon successful enrollment, you can authenticate using your security key by simply touching the token again when requested: . Easy, right?! . ",
    "url": "/docs/features/2fa/security-key.html",
    "relUrl": "/features/2fa/security-key.html"
  },"137": {
    "doc": "Security Keys",
    "title": "Limitations",
    "content": "Users currently can only enroll a single U2F device in Authelia. Multiple single type device enrollment will be available when this issue has been resolved. ",
    "url": "/docs/features/2fa/security-key.html#limitations",
    "relUrl": "/features/2fa/security-key.html#limitations"
  },"138": {
    "doc": "Security Keys",
    "title": "FAQ",
    "content": "Why don’t I have access to the Security Key option? . U2F protocol is a new protocol that is only supported by recent browsers and might even be enabled on some of them. Please be sure your browser supports U2F and that the feature is enabled to make the option available in Authelia. ",
    "url": "/docs/features/2fa/security-key.html#faq",
    "relUrl": "/features/2fa/security-key.html#faq"
  },"139": {
    "doc": "Server",
    "title": "Server",
    "content": "The server section configures and tunes the http server module Authelia uses. ",
    "url": "/docs/configuration/server.html",
    "relUrl": "/configuration/server.html"
  },"140": {
    "doc": "Server",
    "title": "Configuration",
    "content": "# Configuration options specific to the internal http server server: # Buffers usually should be configured to be the same value. # Explanation at https://docs.authelia.com/configuration/server.html # Read buffer size configures the http server's maximum incoming request size in bytes. read_buffer_size: 4096 # Write buffer size configures the http server's maximum outgoing response size in bytes. write_buffer_size: 4096 # Set the single level path Authelia listens on, must be alphanumeric chars and should not contain any slashes. path: \"\" . Buffer Sizes . The read and write buffer sizes generally should be the same. This is because when Authelia verifies if the user is authorized to visit a URL, it also sends back nearly the same size response (write_buffer_size) as the request (read_buffer_size). Path . Authelia by default is served from the root / location, either via its own domain or subdomain. Example: https://auth.example.com/, https://example.com/ . server: path: \"\" . Modifying this setting will allow you to serve Authelia out from a specified base path. Please note that currently only a single level path is supported meaning slashes are not allowed, and only alphanumeric characters are supported. Example: https://auth.example.com/authelia/, https://example.com/authelia/ . server: path: authelia . ",
    "url": "/docs/configuration/server.html#configuration",
    "relUrl": "/configuration/server.html#configuration"
  },"141": {
    "doc": "Session",
    "title": "Session",
    "content": "Authelia relies on session cookies to authenticate users. When the user visits a website of the protected domain example.com for the first time, Authelia detects that there is no cookie for that user. Consequently, Authelia redirects the user to the login portal through which the user should authenticate to get a cookie which is valid for *.example.com, meaning all websites of the domain. At the next request, Authelia receives the cookie associated to the authenticated user and can then order the reverse proxy to let the request pass through to the application. ",
    "url": "/docs/configuration/session.html",
    "relUrl": "/configuration/session.html"
  },"142": {
    "doc": "Session",
    "title": "Configuration",
    "content": "session: # The name of the session cookie. (default: authelia_session). name: authelia_session # The secret to encrypt the session data. This is only used with Redis. # Secret can also be set using a secret: https://docs.authelia.com/configuration/secrets.html secret: unsecure_session_secret # The time in seconds before the cookie expires and session is reset. expiration: 1h # The inactivity time in seconds before the session is reset. inactivity: 5m # The remember me duration. # Value of 0 disables remember me. # Value is in seconds, or duration notation. See: https://docs.authelia.com/configuration/index.html#duration-notation-format # Longer periods are considered less secure because a stolen cookie will last longer giving attackers more time to spy # or attack. Currently the default is 1M or 1 month. remember_me_duration: 1M # The domain to protect. # Note: the login portal must also be a subdomain of that domain. domain: example.com # The redis connection details (optional) # If not provided, sessions will be stored in memory redis: host: 127.0.0.1 port: 6379 ## Use a unix socket instead # host: /var/run/redis/redis.sock ## Optional username to be used with authentication. username: authelia ## Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: authelia ## This is the Redis DB Index https://redis.io/commands/select (sometimes referred to as database number, DB, etc). database_index: 0 ## The maximum number of concurrent active connections to Redis. maximum_active_connections: 8 ## The target number of idle connections to have open ready for work. Useful when opening connections is slow. minimum_idle_connections: 0 ## The Redis TLS configuration. If defined will require a TLS connection to the Redis instance(s). tls: ## Server Name for certificate validation (in case you are using the IP or non-FQDN in the host option). server_name: myredis.example.com ## Skip verifying the server certificate (to allow a self-signed certificate). ## In preference to setting this we strongly recommend you add the public portion of the certificate to the ## certificates directory which is defined by the `certificates_directory` option at the top of the config. skip_verify: false ## Minimum TLS version for the connection. minimum_version: TLS1.2 ## The Redis HA configuration options. ## This provides specific options to Redis Sentinel, sentinel_name must be defined (Master Name). high_availability: ## Sentinel Name / Master Name sentinel_name: mysentinel ## Specific password for Redis Sentinel. The node username and password is configured above. sentinel_password: sentinel_specific_pass ## The additional nodes to pre-seed the redis provider with (for sentinel). ## If the host in the above section is defined, it will be combined with this list to connect to sentinel. ## For high availability to be used you must have either defined; the host above or at least one node below. nodes: - host: sentinel-node1 port: 6379 - host: sentinel-node2 port: 6379 ## Choose the host with the lowest latency. route_by_latency: false ## Choose the host randomly. route_randomly: false . Security . Configuration of this section has an impact on security. You should read notes in security measures for more information. Duration Notation . The configuration parameters expiration, inactivity, and remember_me_duration use duration notation. See the documentation for duration notation format for more information. ",
    "url": "/docs/configuration/session.html#configuration",
    "relUrl": "/configuration/session.html#configuration"
  },"143": {
    "doc": "Session",
    "title": "IPv6 Addresses",
    "content": "If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . ",
    "url": "/docs/configuration/session.html#ipv6-addresses",
    "relUrl": "/configuration/session.html#ipv6-addresses"
  },"144": {
    "doc": "Session",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/session.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/session.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"145": {
    "doc": "Session",
    "title": "Redis Sentinel",
    "content": "When using Redis Sentinel, the host specified in the main redis section is added (it will be the first node) to the nodes in the high availability section. This however is optional. ",
    "url": "/docs/configuration/session.html#redis-sentinel",
    "relUrl": "/configuration/session.html#redis-sentinel"
  },"146": {
    "doc": "Single Factor",
    "title": "Single Factor",
    "content": "Authelia supports single factor authentication to let applications send authenticated requests to other applications. Single or two-factor authentication can be configured per resource of an application for flexibility. For instance, you can configure Authelia to grant access to all resources matching app1.example.com/api/(.*) with only a single factor and all resources matching app1.example.com/admin with two factors. To know more about the configuration of the feature, please visit the documentation about the configuration. ",
    "url": "/docs/features/single-factor.html",
    "relUrl": "/features/single-factor.html"
  },"147": {
    "doc": "Single Factor",
    "title": "HTTP Basic Auth",
    "content": "Authelia supports two different methods for basic auth. Proxy-Authorization header . Authelia reads credentials from the header Proxy-Authorization instead of the usual Authorization header. This is because in some circumstances both Authelia and the application could require authentication in order to provide specific authorizations at the level of the application. API argument . If instead of the Proxy-Authorization header you want, or need, to use the more conventional Authorization header, you should then configure your reverse-proxy to use /api/verify?auth=basic. When authentication fails and auth=basic was set, Authelia’s response will include the WWW-Authenticate header. This will cause browsers to prompt for authentication, and users will not land on the HTML login page. ",
    "url": "/docs/features/single-factor.html#http-basic-auth",
    "relUrl": "/features/single-factor.html#http-basic-auth"
  },"148": {
    "doc": "Single Factor",
    "title": "Session-Username header",
    "content": "Authelia by default only verifies the cookie and the associated user with that cookie can access a protected resource. The client browser does not know the username and does not send this to Authelia, it’s stored by Authelia for security reasons. The Session-Username header has been implemented as a means to use Authelia with non-web services such as PAM. Basically how it works is if the Session-Username header is sent in the request to the /api/verify endpoint it will only respond with a sucess message if the cookie username and the header username match. Example . These examples are for demonstration purposes only, the original use case and full instructions are described here. You will need to adjust the FORWARDED_HOST and VERIFY_URL vars to achieve a functional result. PAM Rule . auth [success=1 default=ignore] pam_exec.so expose_authtok /usr/bin/pam-authelia . PAM Script . #!/bin/bash # The password from stdin PAM_PASSWORD=$(cat -) # url from which authelia session key was created FORWARDED_HOST=auth.example.com # internal path to verify api VERIFY_URL=http://127.0.0.1:80/api/verify AUTH_RESULT=$(curl -b \"authelia_session=${PAM_PASSWORD}\" -H \"Session-Username: ${PAM_USER}\" -H \"X-Forwarded-Host: ${FORWARDED_HOST}\" -H \"X-Forwarded-Proto: https\" -s -o /dev/null -I -w \"%{http_code}\" -L \"${VERIFY_URL}\") if [[ \"$AUTH_RESULT\" == 200 ]]; then echo \"Auth verify ok\" exit 0 else echo \"Auth verify failed $AUTH_RESULT\" exit 1 fi . ",
    "url": "/docs/features/single-factor.html#session-username-header",
    "relUrl": "/features/single-factor.html#session-username-header"
  },"149": {
    "doc": "SMTP",
    "title": "SMTP",
    "content": "Authelia can send emails to users through an SMTP server. It can be configured as described below. # Configuration of the notification system. # # Notifications are sent to users when they require a password reset, a u2f # registration or a TOTP registration. # Use only an available configuration: filesystem, smtp. notifier: # You can disable the notifier startup check by setting this to true. disable_startup_check: false # For testing purpose, notifications can be sent in a file ## filesystem: ## filename: /config/notification.txt # Use a SMTP server for sending notifications. Authelia uses PLAIN or LOGIN method to authenticate. # [Security] By default Authelia will: # - force all SMTP connections over TLS including unauthenticated connections # - use the disable_require_tls boolean value to disable this requirement (only works for unauthenticated connections) # - validate the SMTP server x509 certificate during the TLS handshake against the hosts trusted certificates (configure in tls section) smtp: username: test # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: password host: 127.0.0.1 port: 1025 sender: admin@example.com # HELO/EHLO Identifier. Some SMTP Servers may reject the default of localhost. identifier: localhost # Subject configuration of the emails sent. # {title} is replaced by the text from the notifier subject: \"[Authelia] {title}\" # This address is used during the startup check to verify the email configuration is correct. It's not important what it is except if your email server only allows local delivery. startup_check_address: test@authelia.com disable_require_tls: false disable_html_emails: false tls: # Server Name for certificate validation (in case you are using the IP or non-FQDN in the host option). # server_name: smtp.example.com # Skip verifying the server certificate (to allow a self-signed certificate). skip_verify: false # Minimum TLS version for either StartTLS or SMTPS. minimum_version: TLS1.2 # Sending an email using a Gmail account is as simple as the next section. # You need to create an app password by following: https://support.google.com/accounts/answer/185833?hl=en ## smtp: ## username: myaccount@gmail.com ## # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html ## password: yourapppassword ## sender: admin@example.com ## host: smtp.gmail.com ## port: 587 . ",
    "url": "/docs/configuration/notifier/smtp.html",
    "relUrl": "/configuration/notifier/smtp.html"
  },"150": {
    "doc": "SMTP",
    "title": "Configuration options",
    "content": "Most configuration options are self-explanatory, however here is an explanation of the ones that may not be as obvious. host . If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . identifier . The name to send to the SMTP server as the identifier with the HELO/EHLO command. Some SMTP providers like Google Mail reject the message if it’s localhost. subject . This is the subject Authelia will use in the email, it has a single placeholder at present {title} which should be included in all emails as it is the internal descriptor for the contents of the email. disable_require_tls . For security reasons the default settings for Authelia require the SMTP connection is encrypted by TLS. See security for more information. This option disables this measure (not recommended). disable_html_emails . This option forces Authelia to only send plain text email via the notifier. This is the default for the file based notifier, but some users may wish to use plain text for security reasons. TLS (section) . The key tls is a map of options for tuning TLS options. You can see how to configure the tls section here. ",
    "url": "/docs/configuration/notifier/smtp.html#configuration-options",
    "relUrl": "/configuration/notifier/smtp.html#configuration-options"
  },"151": {
    "doc": "SMTP",
    "title": "Using Gmail",
    "content": "You need to generate an app password in order to use Gmail SMTP servers. The process is described here . notifier: smtp: username: myaccount@gmail.com # Password can also be set using a secret: https://docs.authelia.com/configuration/secrets.html password: yourapppassword sender: admin@example.com host: smtp.gmail.com port: 587 . ",
    "url": "/docs/configuration/notifier/smtp.html#using-gmail",
    "relUrl": "/configuration/notifier/smtp.html#using-gmail"
  },"152": {
    "doc": "SMTP",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/notifier/smtp.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/notifier/smtp.html#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"153": {
    "doc": "SQLite",
    "title": "SQLite",
    "content": "If you don’t have a SQL server, you can use SQLite. However please note that this setup will prevent you from running multiple instances of Authelia since the database will be a local file. ",
    "url": "/docs/configuration/storage/sqlite.html",
    "relUrl": "/configuration/storage/sqlite.html"
  },"154": {
    "doc": "SQLite",
    "title": "Configuration",
    "content": "Just give the path to the sqlite database. It will be created if the file does not exist. storage: local: path: /config/db.sqlite3 . ",
    "url": "/docs/configuration/storage/sqlite.html#configuration",
    "relUrl": "/configuration/storage/sqlite.html#configuration"
  },"155": {
    "doc": "Suites",
    "title": "Suites",
    "content": "Authelia is a single component in interaction with many others in a complete ecosystem. Consequently, testing the features is not as easy as we might think. In order to solve this problem, Authelia came up with the concept of suite which is a kind of virtual environment for Authelia and a set of tests. A suite can setup components such as nginx, redis or mariadb in which Authelia can run and be tested. This abstraction allows to prepare an environment for manual testing during development and also to craft and run integration tests efficiently. ",
    "url": "/docs/contributing/suites.html",
    "relUrl": "/contributing/suites.html"
  },"156": {
    "doc": "Suites",
    "title": "Start a suite.",
    "content": "Starting a suite called Standalone is done with the following command: . $ authelia-scripts suites setup Standalone . This command deploys the environment of the suite. ",
    "url": "/docs/contributing/suites.html#start-a-suite",
    "relUrl": "/contributing/suites.html#start-a-suite"
  },"157": {
    "doc": "Suites",
    "title": "Run tests of a suite",
    "content": "Run tests of running suite . If a suite is already running, you can simply type the test command that will run the test related to the currently running suite: . $ authelia-scripts suites test . Run tests of non-running suite . However, if no suite is running yet and you just want to run the tests of a specific suite like HighAvailability, you can do so with the next command: . # Set up the env, run the tests and tear down the env $ authelia-scripts suites test HighAvailability . Run all tests of all suites . Running all tests is easy. Make sure that no suite is already running and run: . $ authelia-scripts suites test . Run tests in headless mode . As you might have noticed, the tests are run using chromedriver and selenium. It means that the tests open an instance of Chrome that might interfere with your other activities. In order to run the tests in headless mode to avoid the interference, use the following command: . $ authelia-scripts suites test --headless . ",
    "url": "/docs/contributing/suites.html#run-tests-of-a-suite",
    "relUrl": "/contributing/suites.html#run-tests-of-a-suite"
  },"158": {
    "doc": "Suites",
    "title": "Create a suite",
    "content": "Creating a suite is as easy. Let’s take the example of the Standalone suite: . | suite_standalone.go - It defines the setup and teardown phases. It likely uses docker-compose to setup the ecosystem. This file also defines the timeouts. | suite_standalone_test.go - It defines the set of tests to run against the suite. | Standalone directory - It contains resources required by the suite and likely mounted in the containers. | . A suite can also be much more complex like setting up a complete Kubernetes ecosystem. You can check the Kubernetes suite as example. ",
    "url": "/docs/contributing/suites.html#create-a-suite",
    "relUrl": "/contributing/suites.html#create-a-suite"
  },"159": {
    "doc": "Theme",
    "title": "Theme",
    "content": "The theme section configures the theme and style Authelia uses. There are currently 3 available themes for Authelia: . | light (default) | dark | grey | . ",
    "url": "/docs/configuration/theme.html",
    "relUrl": "/configuration/theme.html"
  },"160": {
    "doc": "Theme",
    "title": "Configuration",
    "content": "# The theme to display: light, dark, grey theme: light . ",
    "url": "/docs/configuration/theme.html#configuration",
    "relUrl": "/configuration/theme.html#configuration"
  },"161": {
    "doc": "Threat Model",
    "title": "Threat Model",
    "content": "The design goals for Authelia is to protect access to applications by collaborating with reverse proxies to prevent attacks coming from the edge of the network. This document gives an overview of what Authelia is protecting against but some of those points are also detailed in Security Measures. ",
    "url": "/docs/security/threat-model.html",
    "relUrl": "/security/threat-model.html"
  },"162": {
    "doc": "Threat Model",
    "title": "General assumptions",
    "content": "Authelia is considered to be running within a trusted network and it heavily relies on the first level of security provided by reverse proxies. It’s very important that you take time configuring your reverse proxy properly to get all the authentication benefits brought by Authelia. Some general security tweaks are listed in Security Measures to give you some ideas. ",
    "url": "/docs/security/threat-model.html#general-assumptions",
    "relUrl": "/security/threat-model.html#general-assumptions"
  },"163": {
    "doc": "Threat Model",
    "title": "Guarantees",
    "content": "If properly configured, Authelia guarantees the following for security of your users and your apps: . | Applications cannot be accessed without proper authorization. The access control list is highly configurable allowing administrators to guarantee least privilege principle. | Applications can be protected with two factors in order to fight against credentials theft and protect highly sensitive data or operations. | Sessions are bound in time, limiting the impact of a cookie theft. Sessions can have both soft and hard limits. With soft limit, the user is logged out when inactive for a certain period. With hard limit, the user has to authenticate again after a certain period, whether they were active or not. | Brute force attacks against credentials are protected thanks to a regulation mechanism temporarily blocking the user account after too many attempts. | Identity validation is required for performing administrative actions such as registering 2FA devices, preventing attackers to pass second factor by auto-registering their own 2FA device. An email with a link is sent to the user and a click is required to confirm the action. | Prevention against session fixation by regenerating a new session after each privilege elevation. | Prevention against LDAP injection by following OWASP recommendations regarding valid input characters (https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html). | Connections between Authelia and thirdparty components like mail server, database, cache and LDAP server can be made over TLS to protect against man-in-the-middle attacks from within the infrastructure. | Validation of user session group memberships gets refreshed regularly from the authentication backend (LDAP only). | . ",
    "url": "/docs/security/threat-model.html#guarantees",
    "relUrl": "/security/threat-model.html#guarantees"
  },"164": {
    "doc": "Threat Model",
    "title": "Potential future guarantees",
    "content": ". | Define and enforce a password policy (to be designed since such a policy can clash with a policy set by the LDAP server). | Detect credential theft and prevent malicious actions. | Detect session cookie theft and prevent malicious actions. | Authenticate communications between Authelia and reverse proxy. | Securely transmit authentication data to backends (OAuth2 with bearer tokens). | Protect secrets stored in DB with encryption to prevent secrets leak by DB exfiltration. | Least privilege on LDAP binding operations (currently administrative user is used to bind while it could be anonymous). | Extend the check of user group memberships to authentication backends other than LDAP (File currently). | Invalidate user session after profile or membership has changed in order to drop remaining privileges on the fly. | . ",
    "url": "/docs/security/threat-model.html#potential-future-guarantees",
    "relUrl": "/security/threat-model.html#potential-future-guarantees"
  },"165": {
    "doc": "Threat Model",
    "title": "Trusted environment",
    "content": "It’s important to note that Authelia is considered running in a trusted environment for two reasons . | Requests coming to Authelia should be initiated by reverse proxies but CAN be initiated by any other server currently. There is no trusted relationship between Authelia and the reverse proxy so an attacker within the network could abuse Authelia and attack it. | Your environment should be considered trusted especially if you’re using the Remote-User, Remote-Name, Remote-Email and Remote-Groups headers to forward authentication data to your backends. These headers are transmitted plain and unsigned to the backends, meaning a malicious user within the network could pretend to be Authelia and send those headers to bypass authentication and gain access to the service. A mitigation could be to transmit those headers with a digital signature which could be verified by the backend however, many backends just don’t support it. It has therefore been decided to invest on OpenID Connect instead to solve that authentication delegation problem. Indeed, many backends do support OAuth2 though since it has become a standard lately. | . ",
    "url": "/docs/security/threat-model.html#trusted-environment",
    "relUrl": "/security/threat-model.html#trusted-environment"
  },"166": {
    "doc": "Traefik 1.x",
    "title": "Traefik",
    "content": "Traefik 1.x is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/traefik1.x.html#traefik",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html#traefik"
  },"167": {
    "doc": "Traefik 1.x",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Traefik 1.x | Authelia portal | Protected endpoint (Nextcloud) | Protected endpoint with Authorization header for basic authentication (Heimdall) | . The below configuration looks to provide examples of running Traefik 1.x with labels to protect your endpoint (Nextcloud in this case). Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. Basic Authentication . Authelia provides the means to be able to authenticate your first factor via the Proxy-Authorization header. Given that this is not compatible with Traefik 1.x you can call Authelia’s /api/verify endpoint with the auth=basic query parameter to force a switch to the Authentication header. docker-compose.yml . version: '3' networks: net: driver: bridge services: traefik: image: traefik:v1.7.20-alpine container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - 'traefik.frontend.rule=Host:traefik.example.com' - 'traefik.port=8081' ports: - 80:80 - 443:443 - 8081:8081 restart: unless-stopped command: - '--api' - '--api.entrypoint=api' - '--docker' - '--defaultentrypoints=https' - '--logLevel=DEBUG' - '--traefiklog=true' - '--traefiklog.filepath=/var/log/traefik.log' - '--entryPoints=Name:http Address::80' - '--entryPoints=Name:https Address::443 TLS' - '--entryPoints=Name:api Address::8081' authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/config networks: - net labels: - 'traefik.frontend.rule=Host:login.example.com' expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - 'traefik.frontend.rule=Host:nextcloud.example.com' - 'traefik.frontend.auth.forward.address=http://authelia:9091/api/verify?rd=https://login.example.com/' - 'traefik.frontend.auth.forward.trustForwardHeader=true' - 'traefik.frontend.auth.forward.authResponseHeaders=Remote-User,Remote-Groups,Remote-Name,Remote-Email' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne heimdall: image: linuxserver/heimdall container_name: heimdall volumes: - /path/to/heimdall/config:/config networks: - net labels: - 'traefik.frontend.rule=Host:heimdall.example.com' - 'traefik.frontend.auth.forward.address=http://authelia:9091/api/verify?auth=basic - 'traefik.frontend.auth.forward.trustForwardHeader=true' - 'traefik.frontend.auth.forward.authResponseHeaders=Remote-User,Remote-Groups,Remote-Name,Remote-Email' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne . ",
    "url": "/docs/deployment/supported-proxies/traefik1.x.html#configuration",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html#configuration"
  },"168": {
    "doc": "Traefik 1.x",
    "title": "Traefik 1.x",
    "content": " ",
    "url": "/docs/deployment/supported-proxies/traefik1.x.html",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html"
  },"169": {
    "doc": "Traefik 2.x",
    "title": "Traefik2",
    "content": "Traefik 2.x is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html#traefik2",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html#traefik2"
  },"170": {
    "doc": "Traefik 2.x",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Traefik 2.x | Authelia portal | Protected endpoint (Nextcloud) | Protected endpoint with Authorization header for basic authentication (Heimdall) | . The below configuration looks to provide examples of running Traefik 2.x with labels to protect your endpoint (Nextcloud in this case). Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. Basic Authentication . Authelia provides the means to be able to authenticate your first factor via the Proxy-Authorization header, this is compatible with Traefik &gt;= 2.4.1. If you are running Traefik &lt; 2.4.1, or you have a use-case which requires the use of the Authorization header/basic authentication login prompt you can call Authelia’s /api/verify endpoint with the auth=basic query parameter to force a switch to the Authentication header. docker-compose.yml . version: '3' networks: net: driver: bridge services: traefik: image: traefik:v2.2 container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.api.rule=Host(`traefik.example.com`)' - 'traefik.http.routers.api.entrypoints=https' - 'traefik.http.routers.api.service=api@internal' - 'traefik.http.routers.api.tls=true' ports: - 80:80 - 443:443 command: - '--api' - '--providers.docker=true' - '--providers.docker.exposedByDefault=false' - '--entrypoints.http=true' - '--entrypoints.http.address=:80' - '--entrypoints.http.http.redirections.entrypoint.to=https' - '--entrypoints.http.http.redirections.entrypoint.scheme=https' - '--entrypoints.https=true' - '--entrypoints.https.address=:443' - '--log=true' - '--log.level=DEBUG' - '--log.filepath=/var/log/traefik.log' authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/config networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.authelia.rule=Host(`login.example.com`)' - 'traefik.http.routers.authelia.entrypoints=https' - 'traefik.http.routers.authelia.tls=true' - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.example.com/' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' - 'traefik.http.middlewares.authelia-basic.forwardauth.address=http://authelia:9091/api/verify?auth=basic' - 'traefik.http.middlewares.authelia-basic.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia-basic.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.nextcloud.rule=Host(`nextcloud.example.com`)' - 'traefik.http.routers.nextcloud.entrypoints=https' - 'traefik.http.routers.nextcloud.tls=true' - 'traefik.http.routers.nextcloud.middlewares=authelia@docker' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne heimdall: image: linuxserver/heimdall container_name: heimdall volumes: - /path/to/heimdall/config:/config networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.heimdall.rule=Host(`heimdall.example.com`)' - 'traefik.http.routers.heimdall.entrypoints=https' - 'traefik.http.routers.heimdall.tls=true' - 'traefik.http.routers.heimdall.middlewares=authelia-basic@docker' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne . ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html#configuration",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html#configuration"
  },"171": {
    "doc": "Traefik 2.x",
    "title": "FAQ",
    "content": "Middleware authelia@docker not found . If Traefik and Authelia are defined in different docker compose stacks you may experience an issue where Traefik complains that: middleware authelia@docker not found. This can be avoided a couple different ways: . | Ensure Authelia container is up before Traefik is started: . | Utilise the depends_on option | . | Define the Authelia middleware on your Traefik container - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.example.com/' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' . | . ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html#faq",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html#faq"
  },"172": {
    "doc": "Traefik 2.x",
    "title": "Traefik 2.x",
    "content": " ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html"
  },"173": {
    "doc": "2FA through basic auth",
    "title": "authelia-basic-2fa",
    "content": " ",
    "url": "/docs/community/two-factor-basic-auth.html#authelia-basic-2fa",
    "relUrl": "/community/two-factor-basic-auth.html#authelia-basic-2fa"
  },"174": {
    "doc": "2FA through basic auth",
    "title": "2FA through basic auth",
    "content": "The following project allows you to use Authelia’s one-time password (OTP) 2-factor authentication (2FA) through only basic auth and a custom credentials format described below. This allows you to use 2FA on clients and scenarios that demand basic auth, e.g. webdav network streaming. More information: . ",
    "url": "/docs/community/two-factor-basic-auth.html",
    "relUrl": "/community/two-factor-basic-auth.html"
  },"175": {
    "doc": "Using Remote-User header for SSO with Jira",
    "title": "Using Remote-User header for SSO with Jira",
    "content": "You can make Jira auto-login to the user that is currently logged in to authelia. I say “auto-login” as I couldn’t find any plugin to actually be authentication provider through HTTP headers only - LDAP though seems to have support. So this guide is targeted to authelia users that don’t use any other authentication backend. I’m using traefik with docker as an example, but any proxy that can forward authelia Remote-User header is fine. First of all, users should exist on both authelia and Jira AND have the same username for this to work. Also you will have to pay for a plugin. After both steps are done: . | Add traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User in the labels of authelia | Add traefik.http.routers.jira.middlewares=authelia@docker in the labels of Jira (to actually enable authelia for the jira instance) | Install EasySSO in Jira | Go to EasySSO preferences and add the “Remote-User” header under HTTP and tick the “Username” checkbox. | Save | . ",
    "url": "/docs/community/using-remote-user-header-for-sso-with-jira.html",
    "relUrl": "/community/using-remote-user-header-for-sso-with-jira.html"
  },"176": {
    "doc": "Using Remote-User header for SSO with Jira",
    "title": "Other Systems",
    "content": "While this guide is tailored for Jira, you can use a similar method with many other services like Jenkins and Grafana. ",
    "url": "/docs/community/using-remote-user-header-for-sso-with-jira.html#other-systems",
    "relUrl": "/community/using-remote-user-header-for-sso-with-jira.html#other-systems"
  }
}
